---
alwaysApply: true
---

# Cursor Rules for Dotore Admin Project

## Project Overview
This is a React 19 + TypeScript admin dashboard application using Material-UI (MUI), React Router, and TinyMCE. The project follows a component-based architecture with Context API for global state management.

## Tech Stack
- **Framework**: React 19.2.0 with TypeScript 5.9.3
- **Build Tool**: Vite 7.2.2
- **UI Library**: Material-UI (MUI) 7.3.5
- **Routing**: React Router DOM 7.9.6
- **Rich Text Editor**: TinyMCE 8.2.2 (@tinymce/tinymce-react 6.3.0)
- **State Management**: React Context API
- **Styling**: Emotion (via MUI), CSS-in-JS with `sx` prop

## Project Structure

```
src/
├── components/     # Reusable UI components
├── pages/          # Page-level components (routes)
├── context/        # React Context providers
├── utils/          # Utility functions
├── types/          # TypeScript type definitions
├── themes/         # MUI theme customization
└── data/           # Mock data and constants
```

## Page Structure

애플리케이션의 페이지 구조는 다음과 같이 계층적으로 구성되어 있습니다:

### 인증 전 페이지 (Public Routes)
- **`/login`** - `LoginPage.tsx`
  - 로그인 페이지 (인증 필요 없음)

### 인증 후 페이지 (Private Routes - Layout 내부)
모든 인증 후 페이지는 `Layout` 컴포넌트로 감싸져 있으며, 사이드바와 상단 네비게이션을 포함합니다.

#### 메인 페이지
- **`/`** (index) - `InquiryListPage.tsx`
  - 문의 목록 페이지 (기본 페이지)

#### 문의 관리
- **`/analysis`** - `InquiryAnalysisPage.tsx`
  - 문의 분석 페이지
  - 상위: `/` (문의 목록)

#### 자동 메일 관리
- **`/auto-mail`** - `AutoMailPage.tsx`
  - 자동 메일 그룹 및 템플릿 목록 페이지
- **`/auto-mail/:groupId/:templateId`** - `MailTemplatePage.tsx`
  - 자동 메일 템플릿 편집 페이지
  - 상위: `/auto-mail` (자동 메일 목록)
  - 동적 라우트: `groupId`, `templateId` 파라미터 사용

#### 수동 메일 관리
- **`/manual-mail`** - `ManualMailPage.tsx`
  - 수동 메일 그룹 및 템플릿 목록 페이지
- **`/manual-mail/:groupId/:templateId`** - `MailTemplatePage.tsx`
  - 수동 메일 템플릿 편집 페이지
  - 상위: `/manual-mail` (수동 메일 목록)
  - 동적 라우트: `groupId`, `templateId` 파라미터 사용

### 페이지 계층 구조 요약
```
/login (인증 전)
  └─ LoginPage

/ (인증 후 - Layout)
  ├─ / (index)
  │  └─ InquiryListPage
  │
  ├─ /analysis
  │  └─ InquiryAnalysisPage
  │     └─ 상위: InquiryListPage
  │
  ├─ /auto-mail
  │  └─ AutoMailPage
  │     └─ /auto-mail/:groupId/:templateId
  │        └─ MailTemplatePage
  │           └─ 상위: AutoMailPage
  │
  └─ /manual-mail
     └─ ManualMailPage
        └─ /manual-mail/:groupId/:templateId
           └─ MailTemplatePage
              └─ 상위: ManualMailPage
```

### 페이지 파일 위치
모든 페이지 컴포넌트는 `src/pages/` 디렉토리에 위치합니다:
- `LoginPage.tsx`
- `InquiryListPage.tsx`
- `InquiryAnalysisPage.tsx`
- `AutoMailPage.tsx`
- `ManualMailPage.tsx`
- `MailTemplatePage.tsx`

## Code Style & Conventions

### TypeScript
- Use strict TypeScript with explicit types
- Prefer interfaces for object shapes, types for unions/intersections
- Use `as const` for literal types when needed (e.g., TinyMCE menu items)
- Avoid `any` - use `unknown` or proper types instead
- Use type assertions sparingly and only when necessary

### React Patterns
- Use functional components with hooks
- Prefer named exports for components
- Use `React.useRef` for DOM references and mutable values
- Use `React.useState` for local component state
- Use `React.useEffect` with proper dependency arrays
- Use `React.useCallback` and `React.useMemo` for performance optimization when needed

### Tab-Based UI Patterns
탭 기반 UI를 구현할 때는 각 탭마다 완전히 독립적인 컴포넌트와 로직을 사용해야 합니다.

#### Tab Panel Structure
- MUI의 `Tabs`와 `Tab` 컴포넌트를 사용합니다
- 각 탭의 내용은 `CustomTabPanel` 컴포넌트로 감싸서 독립적으로 관리합니다
- `CustomTabPanel`은 `hidden` 속성과 조건부 렌더링을 사용하여 탭 전환을 처리합니다

Example pattern:
```typescript
interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function CustomTabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`tabpanel-${index}`}
      aria-labelledby={`tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 0 }}>{children}</Box>}
    </div>
  );
}
```

#### Independent State Management
- **각 탭마다 독립적인 상태를 사용합니다**
  - 하나의 공유 상태를 값만 변경해서 사용하지 않습니다
  - 각 탭마다 별도의 `useState`로 페이지네이션 상태를 관리합니다
  - 예: `autoPage`, `manualPage`, `recipientPage` (각각 독립적인 상태)

#### Independent Handler Functions
- **각 탭마다 독립적인 핸들러 함수를 사용합니다**
  - 공유 핸들러 함수를 사용하지 않습니다
  - 각 탭마다 별도의 핸들러 함수를 정의합니다
  - 예: `handleAutoPageChange`, `handleManualPageChange`, `handleRecipientPageChange`

#### Independent Logic Separation
- **각 탭마다 독립적인 필터링 및 페이지네이션 로직을 사용합니다**
  - 하나의 공유 로직을 조건문으로 분기하지 않습니다
  - 각 탭마다 별도의 `useMemo`로 필터링 및 페이지네이션을 처리합니다
  - 예: `autoFiltered`, `autoPaginated`, `manualFiltered`, `manualPaginated`, `recipientFiltered`, `recipientPaginated`

#### Independent Table Components
- **각 탭마다 독립적인 테이블 컴포넌트를 사용합니다**
  - 하나의 테이블 컴포넌트를 값만 변경해서 재사용하지 않습니다
  - 각 탭의 `CustomTabPanel` 내부에 완전히 독립적인 `Table` 컴포넌트를 배치합니다
  - 각 테이블은 자신만의 헤더, 바디, 페이지네이션을 가집니다

Example structure:
```typescript
<CustomTabPanel value={tabValue} index={0}>
  <TableContainer>
    <Table stickyHeader>
      {/* 자동 탭 전용 테이블 */}
    </Table>
  </TableContainer>
  {/* 자동 탭 전용 페이지네이션 */}
</CustomTabPanel>

<CustomTabPanel value={tabValue} index={1}>
  <TableContainer>
    <Table stickyHeader>
      {/* 수동 탭 전용 테이블 */}
    </Table>
  </TableContainer>
  {/* 수동 탭 전용 페이지네이션 */}
</CustomTabPanel>
```

#### Summary
- **독립적인 상태**: 각 탭마다 별도의 `useState` 사용
- **독립적인 핸들러**: 각 탭마다 별도의 핸들러 함수 정의
- **독립적인 로직**: 각 탭마다 별도의 `useMemo`로 필터링/페이지네이션 처리
- **독립적인 테이블**: 각 탭마다 별도의 `Table` 컴포넌트 사용
- **공유하지 않음**: 하나의 컴포넌트/함수/상태를 값만 변경해서 재사용하지 않음

### Component Organization
- **Components** (`src/components/`): Reusable, presentational components
- **Pages** (`src/pages/`): Route-level components that compose multiple components
- **Context** (`src/context/`): Global state providers with custom hooks
- Each component should be in its own file with matching name

### Naming Conventions
- **Components**: PascalCase (e.g., `MailTemplatePage.tsx`)
- **Files**: Match component name (e.g., `Layout.tsx` for `Layout` component)
- **Hooks**: Start with `use` (e.g., `useSnackbar`, `useLanguage`)
- **Context**: PascalCase with `Context` suffix (e.g., `SnackbarContext`)
- **Types/Interfaces**: PascalCase (e.g., `MailTemplate`, `Language`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `AVAILABLE_VARIABLES`)
- **Functions**: camelCase (e.g., `handleSave`, `getTemplate`)

### MUI Usage
- Always import MUI components from `@mui/material` or `@mui/icons-material`
- Use the `sx` prop for styling instead of `style` prop
- Use theme-aware values in `sx` (e.g., `'primary.main'`, `'text.secondary'`)
- Prefer MUI components over native HTML elements when possible
- Use `styled` API for complex reusable styled components
- Use `useTheme` hook when theme values are needed in JavaScript

### Context API Patterns
- Create Context files in `src/context/` directory
- Export a Provider component and a custom hook (e.g., `useSnackbar`)
- Provider should wrap the entire app in `App.tsx`
- Custom hook should throw error if used outside provider
- Use `useCallback` for context functions to prevent unnecessary re-renders

Example pattern:
```typescript
const Context = createContext<ContextType | undefined>(undefined);

export const useContext = () => {
  const context = useContext(Context);
  if (!context) {
    throw new Error('useContext must be used within Provider');
  }
  return context;
};

export const Provider = ({ children }: { children: React.ReactNode }) => {
  // implementation
  return <Context.Provider value={value}>{children}</Context.Provider>;
};
```

### Routing
- Use React Router DOM v7 patterns
- Define routes in `App.tsx`
- Use `useNavigate` for programmatic navigation
- Use `useLocation` for current route information
- Use `useParams` for route parameters
- Use `Link` component for navigation links

### TinyMCE Integration
- Use `@tinymce/tinymce-react` Editor component
- Keep editor as uncontrolled component (use `initialValue`, not `value`)
- Use `onInit` to get editor reference
- Use `onEditorChange` sparingly to avoid cursor issues with IME input
- Retrieve content with `editorRef.current.getContent()` when needed
- Use `editor.getContent({ format: 'text' })` to get plain text

### State Management
- **Local State**: Use `useState` for component-specific state
- **Global State**: Use Context API (ColorMode, Language, Snackbar)
- **Persistent State**: Use `localStorage` via utility functions in `src/utils/storage.ts`
- Avoid prop drilling - use Context when state is needed across multiple components

### Styling Guidelines
- Use MUI's `sx` prop for component-level styles
- Use theme spacing units (e.g., `sx={{ p: 3, mb: 2 }}`)
- Use theme colors (e.g., `'primary.main'`, `'error.lighter'`)
- Use responsive breakpoints when needed
- Keep styles co-located with components
- Use `styled` API for complex reusable styled components

### Dark Mode Support Guidelines
**모든 작업에 있어서 다크모드가 지원되어야 합니다.** 이는 필수 요구사항이며, 모든 컴포넌트, 페이지, 스타일링 작업에서 반드시 고려해야 합니다.

#### Core Principles
- **항상 다크모드 지원**: 모든 UI 컴포넌트는 라이트 모드와 다크 모드 모두에서 올바르게 작동해야 합니다
- **테마 색상 사용**: 하드코딩된 색상은 절대 사용하지 않습니다
- **자동 색상 전환**: MUI 테마 시스템을 통해 자동으로 색상이 전환되도록 구현합니다
- **테스트 필수**: 모든 스타일 변경사항은 라이트 모드와 다크 모드 모두에서 테스트해야 합니다

#### Color Usage Rules
- **절대 금지**: 하드코딩된 색상 값 사용 금지
  - ❌ `#ffffff`, `#000000`, `#f5f5f5` 등 직접 색상 값 사용 금지
  - ❌ `rgb(255, 255, 255)`, `rgba(0, 0, 0, 0.5)` 등 직접 색상 값 사용 금지
  - ✅ 테마 색상 값 사용: `'text.primary'`, `'background.paper'`, `'primary.main'` 등

- **필수 사용**: 테마 인식 색상 값 사용
  - 텍스트 색상: `'text.primary'`, `'text.secondary'`, `'text.disabled'`
  - 배경 색상: `'background.paper'`, `'background.default'`
  - 구분선 색상: `'divider'`
  - 테마 색상: `'primary.main'`, `'secondary.main'`, `'error.main'`, `'warning.main'`, `'info.main'`, `'success.main'`

- **커스텀 색상 사용 시**: 테마 팔레트에 라이트/다크 변형 모두 제공
  ```typescript
  // 테마 팔레트에 추가
  const theme = createTheme({
    palette: {
      mode: 'light', // 또는 'dark'
      custom: {
        light: '#f5f5f5', // 라이트 모드용
        dark: '#1a1a1a',  // 다크 모드용
      }
    }
  });
  ```

#### Implementation Patterns

##### Using sx Prop (권장)
```typescript
// ✅ 올바른 방법: 테마 색상 사용
<Box
  sx={{
    bgcolor: 'background.paper',
    color: 'text.primary',
    border: '1px solid',
    borderColor: 'divider',
  }}
>
  <Typography color="text.secondary">Content</Typography>
</Box>

// ❌ 잘못된 방법: 하드코딩된 색상
<Box
  sx={{
    bgcolor: '#ffffff',
    color: '#000000',
    border: '1px solid #e0e0e0',
  }}
>
  <Typography sx={{ color: '#666666' }}>Content</Typography>
</Box>
```

##### Using useTheme Hook
```typescript
import { useTheme } from '@mui/material/styles';

const MyComponent = () => {
  const theme = useTheme();

  return (
    <Box
      sx={{
        bgcolor: theme.palette.mode === 'dark'
          ? theme.palette.grey[800]
          : theme.palette.grey[100],
        color: theme.palette.text.primary,
      }}
    >
      Content
    </Box>
  );
};
```

##### Using styled API
```typescript
import { styled } from '@mui/material/styles';

const StyledBox = styled(Box)(({ theme }) => ({
  backgroundColor: theme.palette.background.paper,
  color: theme.palette.text.primary,
  border: `1px solid ${theme.palette.divider}`,
  '&:hover': {
    backgroundColor: theme.palette.action.hover,
  },
}));
```

##### Custom CSS (최후의 수단)
커스텀 CSS를 사용해야 하는 경우, CSS 변수나 테마 인식 셀렉터를 사용합니다:

```typescript
// ✅ CSS 변수 사용
const styles = {
  container: {
    backgroundColor: 'var(--mui-palette-background-paper)',
    color: 'var(--mui-palette-text-primary)',
  }
};

// ✅ 테마 인식 셀렉터
const styles = {
  container: {
    '@media (prefers-color-scheme: dark)': {
      backgroundColor: '#1a1a1a',
      color: '#ffffff',
    },
    '@media (prefers-color-scheme: light)': {
      backgroundColor: '#ffffff',
      color: '#000000',
    },
  }
};
```

#### Component-Specific Guidelines

##### Buttons
```typescript
// ✅ 올바른 방법
<Button
  variant="contained"
  sx={{
    bgcolor: 'primary.main',
    color: 'primary.contrastText',
    '&:hover': {
      bgcolor: 'primary.dark',
    },
  }}
>
  Click me
</Button>
```

##### Cards and Papers
```typescript
// ✅ 올바른 방법
<Paper
  sx={{
    bgcolor: 'background.paper',
    border: '1px solid',
    borderColor: 'divider',
    boxShadow: 'none',
  }}
>
  Content
</Paper>
```

##### Tables
```typescript
// ✅ 올바른 방법
<TableContainer component={Paper}>
  <Table>
    <TableHead>
      <TableRow>
        <TableCell sx={{ color: 'text.primary' }}>Header</TableCell>
      </TableRow>
    </TableHead>
    <TableBody>
      <TableRow>
        <TableCell sx={{ color: 'text.primary' }}>Data</TableCell>
      </TableRow>
    </TableBody>
  </Table>
</TableContainer>
```

##### Dialogs and Modals
```typescript
// ✅ 올바른 방법
<Dialog
  PaperProps={{
    sx: {
      bgcolor: 'background.paper',
      color: 'text.primary',
    },
  }}
>
  <DialogTitle sx={{ color: 'text.primary' }}>Title</DialogTitle>
  <DialogContent sx={{ color: 'text.primary' }}>Content</DialogContent>
</Dialog>
```

##### Icons
```typescript
// ✅ 올바른 방법
<IconButton sx={{ color: 'text.primary' }}>
  <Icon />
</IconButton>
```

#### Image and Media Handling
- **이미지 배경**: 투명 배경 이미지는 다크모드에서도 잘 보이도록 고려
- **로고**: 다크모드용 로고 버전이 필요할 수 있음
- **아이콘**: MUI 아이콘은 자동으로 테마 색상을 따르지만, 커스텀 아이콘은 색상 지정 필요

#### Testing Checklist
모든 스타일 변경 후 다음을 확인해야 합니다:

- [ ] 라이트 모드에서 모든 요소가 올바르게 표시되는가?
- [ ] 다크 모드에서 모든 요소가 올바르게 표시되는가?
- [ ] 텍스트 가독성이 양쪽 모드에서 충분한가?
- [ ] 배경과 텍스트의 대비가 충분한가?
- [ ] 구분선과 테두리가 양쪽 모드에서 명확한가?
- [ ] 호버 상태가 양쪽 모드에서 올바르게 작동하는가?
- [ ] 포커스 상태가 양쪽 모드에서 명확한가?
- [ ] 선택된 상태가 양쪽 모드에서 명확한가?

#### Common Mistakes to Avoid
- ❌ **하드코딩된 색상**: `#ffffff`, `#000000` 등 직접 색상 값 사용
- ❌ **라이트 모드만 고려**: 다크 모드 테스트 누락
- ❌ **배경색만 변경**: 텍스트 색상도 함께 변경하지 않음
- ❌ **투명도 무시**: `rgba(0, 0, 0, 0.1)` 같은 투명도가 다크 모드에서 보이지 않을 수 있음
- ❌ **그림자 무시**: 다크 모드에서 그림자가 보이지 않을 수 있음
- ❌ **이미지 배경**: 투명 배경 이미지가 다크 모드에서 보이지 않을 수 있음

#### Summary
- **필수 요구사항**: 모든 작업에서 다크모드 지원 필수
- **테마 색상 사용**: 하드코딩된 색상 절대 금지
- **자동 전환**: MUI 테마 시스템 활용
- **테스트 필수**: 라이트/다크 모드 모두 테스트
- **일관성 유지**: 모든 컴포넌트에서 동일한 패턴 적용

### Table Design Guidelines
모든 테이블은 일관된 디자인을 유지해야 합니다. 문의 목록 테이블(`InquiryListPage.tsx`)의 스타일 규칙을 표준으로 따릅니다.

#### Table Loading UI (필수)
**테이블과 관련된 컴포넌트를 만들 때 반드시 테이블 로딩 UI가 있어야 하며, 이는 테이블에 데이터를 넣기 전에 보여져야 합니다.**

- **로딩 상태 관리**: `isLoading` 또는 `isLoadingData` 같은 상태 변수를 사용하여 로딩 상태를 관리합니다
- **로딩 UI 표시 위치**: `TableBody` 내부에서 로딩 상태일 때 로딩 UI를 표시합니다
- **로딩 UI 구조**: `CircularProgress`와 로딩 메시지를 포함한 `TableRow`를 사용합니다
- **데이터 로드 전 표시**: 데이터를 불러오기 전에 로딩 UI가 먼저 표시되어야 합니다

Example pattern:
```typescript
const [isLoading, setIsLoading] = useState<boolean>(false);
const [data, setData] = useState<DataType[]>([]);

// 데이터 로드 함수
const loadData = async () => {
  setIsLoading(true);
  try {
    // 네트워크 지연 시뮬레이션 또는 실제 API 호출
    await new Promise(resolve => setTimeout(resolve, 500));
    const fetchedData = await fetchDataFromAPI();
    setData(fetchedData);
  } finally {
    setIsLoading(false);
  }
};

// 컴포넌트 마운트 시 데이터 로드
useEffect(() => {
  loadData();
}, []);

// 테이블 렌더링
<TableBody>
  {isLoading ? (
    <TableRow>
      <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 2 }}>
          <CircularProgress size={40} />
          <Typography variant="body2" color="text.secondary">
            데이터를 불러오는 중...
          </Typography>
        </Box>
      </TableCell>
    </TableRow>
  ) : data.length === 0 ? (
    <TableRow>
      <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 1 }}>
          <Typography variant="h6" color="text.secondary">
            조회된 데이터가 없습니다.
          </Typography>
        </Box>
      </TableCell>
    </TableRow>
  ) : (
    data.map((item) => (
      <TableRow key={item.id}>
        {/* 데이터 행 렌더링 */}
      </TableRow>
    ))
  )}
</TableBody>
```

**Key Points:**
- **필수 구현**: 모든 테이블 컴포넌트에 로딩 UI 구현 필수
- **데이터 로드 전 표시**: 데이터를 불러오기 전에 로딩 UI가 먼저 표시되어야 함
- **로딩 상태 관리**: 비동기 데이터 로드 함수에서 로딩 상태를 적절히 관리
- **일관된 UI**: 모든 테이블에서 동일한 로딩 UI 패턴 사용
- **사용자 경험**: 데이터 로드 중 사용자에게 명확한 피드백 제공

#### Table Container & Wrapper
- 테이블은 `Paper` 컴포넌트로 감싸야 합니다
- Paper 스타일:
  ```typescript
  <Paper
    sx={{
      width: '100%',
      borderRadius: 2,
      border: '1px solid',
      borderColor: 'divider',
      boxShadow: 'none',
    }}
  >
    {/* 테이블 내용 */}
  </Paper>
  ```
- `TableContainer`는 Paper 없이 직접 사용합니다 (Paper 내부에 위치)

#### Table Structure
- `Table` 컴포넌트에 `stickyHeader` 속성을 항상 사용합니다
  ```typescript
  <Table stickyHeader>
  ```

#### Table Head (헤더)
- `TableCell` 헤더에는 `fontWeight`를 명시하지 않습니다 (기본 스타일 사용)
- 모든 헤더 셀에 `whiteSpace: 'nowrap'`을 사용합니다
- 필요시 `width`, `minWidth` 속성을 사용하여 컬럼 너비를 지정합니다
  ```typescript
  <TableCell sx={{ whiteSpace: 'nowrap' }}>헤더 텍스트</TableCell>
  // 또는
  <TableCell sx={{ width: '100px', minWidth: '100px', whiteSpace: 'nowrap' }}>헤더 텍스트</TableCell>
  ```

#### Table Body (바디)
- 모든 바디 셀에 `whiteSpace: 'nowrap'`을 사용합니다
- 셀 내부 텍스트는 `Typography` 컴포넌트로 감싸고 `variant="body2"`를 사용합니다
- 기본 텍스트: `variant="body2"` (색상 없음, 기본 `text.primary`)
- 보조 텍스트: `variant="body2" color="text.secondary"`
- 모든 텍스트에 `noWrap` 속성을 추가합니다
  ```typescript
  <TableCell sx={{ whiteSpace: 'nowrap' }}>
    <Typography variant="body2" noWrap>
      기본 텍스트
    </Typography>
  </TableCell>
  <TableCell sx={{ whiteSpace: 'nowrap' }}>
    <Typography variant="body2" color="text.secondary" noWrap>
      보조 텍스트
    </Typography>
  </TableCell>
  ```

#### Empty State (빈 데이터)
- 빈 데이터 셀은 `colSpan`을 사용하여 전체 컬럼을 차지합니다
- `align="center"`와 `sx={{ py: 8 }}`을 사용합니다
- `Box`로 감싸서 `Typography`를 사용합니다
  ```typescript
  <TableRow>
    <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 1 }}>
        <Typography variant="h6" color="text.secondary">
          조회된 데이터가 없습니다.
        </Typography>
      </Box>
    </TableCell>
  </TableRow>
  ```

#### Table Row
- 데이터 행에는 `hover` 속성을 사용합니다
- 클릭 가능한 행은 `sx={{ cursor: 'pointer' }}`를 추가합니다

#### Table Schema Definitions
**사이드바에서 보여지는 모든 페이지에 테이블 컴포넌트가 있는 경우, 각 테이블의 구조를 정의합니다. 나중에 데이터베이스 스키마 설정 시 필요합니다.**

##### 1. InquiryListPage (문의 목록) - `/`
**테이블명**: `inquiries`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 문의 고유 ID (PK) | ❌ | ✅ |
| `number` | number | 문의 번호 | ❌ | ✅ |
| `category` | string | 카테고리 (InquiryCategory enum) | ✅ | ✅ |
| `user_name` | string | 사용자 이름(아이디) | ✅ | ✅ |
| `user_nickname` | string | 사용자 닉네임 | ✅ | ❌ |
| `user_email` | string | 사용자 이메일 | ✅ | ✅ |
| `user_type` | string | 작성자 유형 (UserType enum) | ✅ | ✅ |
| `title` | string | 문의 내용 (제목) | ✅ | ✅ |
| `attachments` | array | 첨부파일 목록 | ❌ | ❌ |
| `user_country` | string | 사용자 국적 | ✅ | ✅ |
| `created_at` | datetime | 등록일시 | ✅ | ✅ |
| `status` | string | 답변 상태 (InquiryStatus enum) | ✅ | ✅ |
| `answer_content` | text | 답변 내용 | ❌ | ❌ |
| `answerer_id` | string | 답변자 ID | ❌ | ❌ |
| `answered_at` | datetime | 답변 일시 | ❌ | ❌ |

**관계**:
- `user_id` (외래키): 사용자 테이블 참조
- `answerer_id` (외래키): 관리자 테이블 참조

##### 2. MailGroupPage (발송 그룹) - `/mail-group`
**테이블명**: `send_groups`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 그룹 고유 ID (PK) | ❌ | ✅ |
| `name` | MultilingualContent | 그룹 이름 (다국어) | ❌ | ✅ |
| `description` | MultilingualContent | 그룹 설명 (다국어) | ❌ | ❌ |
| `nationality` | string | 국적 조건 (표시용) | ❌ | ❌ |
| `age_range` | string | 연령 범위 조건 (표시용) | ❌ | ❌ |
| `gender` | string | 성별 조건 (표시용) | ❌ | ❌ |
| `user_type` | string | 가입 유형 조건 (표시용) | ❌ | ❌ |
| `signup_method` | string | 가입 방식 조건 (표시용) | ❌ | ❌ |
| `signup_date` | string | 가입 일자 조건 (표시용) | ❌ | ❌ |
| `subscription_status` | string | 구독 여부 조건 (표시용) | ❌ | ❌ |
| `activity_status` | string | 활동 여부 조건 (표시용) | ❌ | ❌ |
| `member_count` | number | 예상 발송 인원 수 | ❌ | ✅ |
| `query` | JSON | Query Builder 조건 (RuleGroupType) | ❌ | ✅ |
| `created_at` | datetime | 생성 일시 | ❌ | ✅ |
| `updated_at` | datetime | 수정 일시 | ❌ | ✅ |
| `member_count_checked_at` | datetime | 인원 조회 일시 | ❌ | ❌ |

**관계**:
- `query` 필드는 JSON 형식으로 저장되며, `react-querybuilder`의 `RuleGroupType` 구조를 따릅니다.

##### 3. MailHistoryPage (발송 이력) - `/mail-history`

###### 3-1. 자동 메일 탭
**테이블명**: `auto_mail_history`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 발송 이력 고유 ID (PK) | ❌ | ✅ |
| `template_name` | string | 템플릿 이름 | ❌ | ✅ |
| `group_name` | string | 그룹 이름 | ❌ | ✅ |
| `recipient_count` | number | 수신자 수 | ❌ | ✅ |
| `sent_count` | number | 발송 성공 수 | ❌ | ✅ |
| `failed_count` | number | 발송 실패 수 | ❌ | ✅ |
| `type` | string | 발송 유형 ('auto') | ❌ | ✅ |

**관계**:
- `template_id` (외래키): 템플릿 테이블 참조
- `group_id` (외래키): 발송 그룹 테이블 참조
- `successful_recipients` (JSON): 성공한 수신자 목록 (각 항목에 `sentAt` 포함)
- `failed_recipients` (JSON): 실패한 수신자 목록 (각 항목에 `sentAt` 포함)

###### 3-2. 수동 메일 탭
**테이블명**: `manual_mail_history`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 발송 이력 고유 ID (PK) | ❌ | ✅ |
| `template_name` | string | 템플릿 이름 | ❌ | ✅ |
| `group_name` | string | 그룹 이름 | ❌ | ✅ |
| `recipient_count` | number | 수신자 수 | ❌ | ✅ |
| `sent_count` | number | 발송 성공 수 | ❌ | ✅ |
| `failed_count` | number | 발송 실패 수 | ❌ | ✅ |
| `status` | string | 발송 상태 | ❌ | ✅ |
| `type` | string | 발송 유형 ('manual') | ❌ | ✅ |
| `sent_date` | datetime | 발송일시 | ❌ | ✅ |
| `sent_by` | string | 발송자 ID | ❌ | ✅ |

**관계**:
- `template_id` (외래키): 템플릿 테이블 참조
- `group_id` (외래키): 발송 그룹 테이블 참조
- `sent_by` (외래키): 관리자 테이블 참조
- `successful_recipients` (JSON): 성공한 수신자 목록
- `failed_recipients` (JSON): 실패한 수신자 목록

**참고사항**:
- 자동 메일은 시스템에서 자동으로 발송되므로 `sent_date`와 `sent_by` 컬럼이 없습니다.
- 수동 메일은 관리자가 수동으로 발송하므로 `sent_date`와 `sent_by` 컬럼이 필요합니다.
- 자동 메일의 경우 각 수신자마다 발송 시간이 다를 수 있으므로, `successful_recipients`와 `failed_recipients` 배열의 각 항목에 개별 `sentAt` 필드가 포함됩니다.

#### Summary
- **로딩 UI 필수**: 모든 테이블 컴포넌트에 로딩 UI 구현 필수, 데이터 로드 전에 표시
- **Paper로 감싸기**: 항상 Paper 컴포넌트로 테이블을 감싸고 표준 스타일 적용
- **stickyHeader**: 모든 Table에 stickyHeader 속성 사용
- **whiteSpace: 'nowrap'**: 모든 TableCell에 적용
- **Typography variant="body2"**: 모든 셀 텍스트에 사용
- **noWrap**: 모든 Typography에 적용
- **헤더 fontWeight**: 명시하지 않음 (기본 스타일)
- **빈 데이터**: py: 8, Box로 감싸서 Typography 사용
- **테이블 스키마 정의**: 각 페이지의 테이블 구조를 명확히 정의하여 데이터베이스 스키마 설계 시 참고

### Date Format Guidelines
모든 날짜 표시는 **YY-MM-DD** 형식을 사용해야 합니다.

#### Date Format Rules
- **표준 형식**: `YY-MM-DD` (연도 2자리, 월 2자리, 일 2자리)
  - 예: `24-01-15` (2024년 1월 15일)
  - 예: `23-12-31` (2023년 12월 31일)
- 날짜만 표시할 때는 `YY-MM-DD` 형식을 사용합니다
- 시간이 필요한 경우 시간은 별도로 표시하거나 `YY-MM-DD HH:MM` 형식을 사용할 수 있습니다
- CSV 내보내기 시에도 동일한 형식을 사용합니다

#### Date Formatting Function Example
```typescript
const formatDateOnly = (dateString: string) => {
  const date = new Date(dateString);
  const year = String(date.getFullYear()).slice(-2);
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};
```

#### Time Formatting Function Example (if needed)
```typescript
const formatTimeOnly = (dateString: string) => {
  const date = new Date(dateString);
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${hours}:${minutes}`;
};
```

#### Summary
- **날짜 형식**: 항상 `YY-MM-DD` 형식 사용
- **월/일**: 항상 2자리로 표시 (padStart 사용)
- **연도**: 마지막 2자리만 표시 (slice(-2) 사용)
- **일관성**: 모든 페이지에서 동일한 형식 유지

### Auto Mail (자동 메일) Design Guidelines
자동 메일 발송은 시스템에서 자동으로 처리되므로, UI 설계 시 다음과 같은 특성을 고려해야 합니다.

#### Auto Mail Characteristics
- **자동 발송**: 시스템에서 자동으로 발송되므로 발송자 정보가 없습니다
- **사용자별 발송 시간**: 각 사용자의 상황에 따라 발송 시간이 다릅니다
- **고정된 발송일 없음**: 전체 발송에 대한 고정된 발송일이 없습니다

#### Auto Mail Table Design Rules
자동 메일 발송 이력 테이블에는 다음 컬럼만 표시해야 합니다:
- 템플릿 이름
- 그룹 이름
- 수신자 수
- 발송 성공
- 발송 실패

**제외해야 할 컬럼:**
- ❌ **상태 컬럼**: 자동 메일 테이블에는 상태 컬럼을 표시하지 않습니다
- ❌ **발송자 컬럼**: 시스템에서 자동으로 발송되므로 발송자 정보가 필요 없습니다
- ❌ **유형 컬럼**: 자동 탭에만 있으므로 유형 정보가 중복됩니다
- ❌ **발송일 컬럼**: 자동 발송은 사용자마다 발송 시간이 다르므로 고정된 발송일이 없습니다

#### Auto Mail Date Display
- **메인 테이블**: 자동 발송의 경우 발송일 셀에 `'-'`를 표시합니다
  ```typescript
  {item.type === 'auto' ? '-' : formatDateOnly(item.sentAt)}
  ```
- **수신자 목록**: 각 수신자별로 실제 발송 시간을 표시합니다 (수신자마다 발송 시간이 다름)

#### Auto Mail Data Structure
- 자동 발송 메일의 `sentAt` 필드는 전체 발송의 기준 시간일 수 있지만, 실제로는 각 수신자마다 다른 시간에 발송됩니다
- `successfulRecipients`와 `failedRecipients` 배열의 각 항목은 개별 발송 시간(`sentAt`)을 가집니다

#### Summary
- **자동 메일 테이블**: 템플릿 이름, 그룹 이름, 수신자 수, 발송 성공, 발송 실패만 표시
- **발송일 표시**: 메인 테이블에서는 `'-'` 표시, 수신자 목록에서는 개별 발송 시간 표시
- **발송자 정보**: 자동 발송은 시스템에서 처리되므로 발송자 정보 불필요
- **상태 정보**: 자동 메일 테이블에는 상태 컬럼 제외

### Error Handling
- Use try-catch for async operations
- Display user-friendly error messages via Snackbar
- Log errors to console for debugging
- Validate inputs before processing

### File Imports
- Group imports: external libraries, MUI components, internal components, utilities, types
- Use absolute imports from `src/` (e.g., `import { useSnackbar } from '../context/SnackbarContext'`)
- Use named imports for MUI components
- Use default imports for React Router hooks

### Performance
- Use `React.memo` for expensive components that re-render frequently
- Use `useCallback` for functions passed as props to memoized components
- Use `useMemo` for expensive computations
- Lazy load heavy components when appropriate
- Avoid creating functions/objects in render without memoization

### Accessibility
- Use semantic HTML elements
- Add `aria-label` to icon-only buttons
- Ensure keyboard navigation works
- Use MUI components which have built-in accessibility

### Testing Considerations
- Write testable components (pure functions when possible)
- Keep business logic separate from UI logic
- Use dependency injection for external services

### Multilingual Content Management
서비스의 이용자는 주로 베트남, 미국, 한국에 거주하며, 모든 사용자에게 보여지는 컨텐츠는 다국어로 관리되어야 합니다.

#### Supported Languages
- **한국어 (Korean)**: `ko` 또는 `ko-KR`
- **영어 (English)**: `en` 또는 `en-US`
- **베트남어 (Vietnamese)**: `vi` 또는 `vi`

#### Multilingual Content Types
다음과 같은 컨텐츠는 반드시 다국어로 등록해야 합니다:
- **공지사항 (Announcements)**: 모든 사용자에게 표시되는 공지사항
- **이벤트 (Events)**: 모든 사용자에게 표시되는 이벤트 정보
- **자동 이메일 발송 템플릿 (Auto Email Templates)**: 자동으로 발송되는 이메일 템플릿
- **수동 이메일 발송 템플릿 (Manual Email Templates)**: 관리자가 수동으로 발송하는 이메일 템플릿
- **템플릿 그룹 (Template Groups)**: 메일 템플릿 그룹의 이름
- **템플릿 이름 (Template Names)**: 각 템플릿의 관리용 이름
- **이메일 제목 (Email Titles)**: 실제 발송되는 이메일의 제목
- **템플릿 설명 (Template Descriptions)**: 템플릿에 대한 설명
- **페이지 제목 (Page Titles)**: 모든 페이지의 제목
- **페이지 설명 (Page Descriptions)**: 페이지 제목 아래에 표시되는 설명
- **고정된 문구 (Fixed Text)**: 버튼 텍스트, 라벨, 플레이스홀더 등 모든 고정된 문구
- 기타 모든 사용자에게 노출되는 컨텐츠

#### Data Structure Pattern
다국어 컨텐츠는 다음과 같은 구조로 관리해야 합니다:

```typescript
interface MultilingualContent {
  ko: string;  // 한국어
  en: string;  // 영어
  vi: string;  // 베트남어
}

// 예시: 공지사항
interface Announcement {
  id: string;
  title: MultilingualContent;
  content: MultilingualContent;
  createdAt: string;
  updatedAt: string;
}

// 예시: 이메일 템플릿
interface EmailTemplate {
  id: string;
  groupId: string;
  name: MultilingualContent;  // 템플릿 이름
  title: MultilingualContent;  // 이메일 제목
  description?: MultilingualContent;  // 템플릿 설명
  content: MultilingualContent;  // HTML content
  variables?: string[];
}

// 예시: 템플릿 그룹
interface MailGroup {
  id: string;
  name: MultilingualContent;  // 그룹 이름
  templates: MailTemplate[];
}
```

#### UI Implementation Pattern
다국어 입력을 위한 UI는 탭 기반 인터페이스를 사용합니다:

```typescript
import { useLanguage } from '../context/LanguageContext';

const { language } = useLanguage();

// 언어에 따라 탭 인덱스 매핑: ko -> 0, en -> 1, vi -> 2
const getLanguageTabIndex = (lang: 'ko' | 'en' | 'vi'): number => {
  switch (lang) {
    case 'ko':
      return 0;
    case 'en':
      return 1;
    case 'vi':
      return 2;
    default:
      return 0;
  }
};

const [languageTab, setLanguageTab] = useState<number>(getLanguageTabIndex(language));
const [content, setContent] = useState<MultilingualContent>({
  ko: '',
  en: '',
  vi: '',
});

const prevLanguageRef = useRef<'ko' | 'en' | 'vi'>(language);

// GNB에서 언어가 변경되면 탭도 자동으로 변경
useEffect(() => {
  if (prevLanguageRef.current !== language) {
    setLanguageTab(getLanguageTabIndex(language));
    prevLanguageRef.current = language;
  }
}, [language]);

// 탭 전환 핸들러
const handleLanguageTabChange = (event: React.SyntheticEvent, newValue: number) => {
  setLanguageTab(newValue);
};

// 언어별 컨텐츠 업데이트
const handleContentChange = (language: 'ko' | 'en' | 'vi', value: string) => {
  setContent((prev) => ({
    ...prev,
    [language]: value,
  }));
};

// UI 구조
<Tabs value={languageTab} onChange={handleLanguageTabChange}>
  {/* 탭 라벨 (다국어 적용 필요) */}
  <Tab label="한국어" />
  <Tab label="English" />
  <Tab label="Tiếng Việt" />
</Tabs>
<CustomTabPanel value={languageTab} index={0}>
  {/* 한국어 입력 필드 */}
  <TextField
    value={content.ko}
    onChange={(e) => handleContentChange('ko', e.target.value)}
    label="제목 (한국어)"  {/* 라벨 (다국어 적용 필요) */}
    fullWidth
  />
</CustomTabPanel>
<CustomTabPanel value={languageTab} index={1}>
  {/* 영어 입력 필드 */}
  <TextField
    value={content.en}
    onChange={(e) => handleContentChange('en', e.target.value)}
    label="Title (English)"  {/* 라벨 (다국어 적용 필요) */}
    fullWidth
  />
</CustomTabPanel>
<CustomTabPanel value={languageTab} index={2}>
  {/* 베트남어 입력 필드 */}
  <TextField
    value={content.vi}
    onChange={(e) => handleContentChange('vi', e.target.value)}
    label="Tiêu đề (Tiếng Việt)"  {/* 라벨 (다국어 적용 필요) */}
    fullWidth
  />
</CustomTabPanel>
```

#### Language-Aware Tab Selection
GNB(Global Navigation Bar)에서 설정한 언어에 따라 다국어 입력 탭이 자동으로 선택되어야 합니다.

- **자동 탭 선택**: GNB에서 언어를 변경하면 해당 언어의 탭이 자동으로 활성화됩니다
- **언어-탭 매핑**: `ko` → 0 (한국어 탭), `en` → 1 (English 탭), `vi` → 2 (Tiếng Việt 탭)
- **실시간 동기화**: `useLanguage` 훅을 통해 현재 언어를 가져오고, 언어 변경 시 `useEffect`로 탭을 자동 전환합니다
- **사용자 수동 선택 가능**: 자동 선택 기능과 함께 사용자가 직접 탭을 선택할 수도 있습니다

#### Validation Rules
- **필수 입력**: 모든 언어에 대한 컨텐츠 입력이 필수입니다
- **빈 값 검증**: 저장 시 각 언어별로 빈 값이 있는지 확인해야 합니다
- **HTML 컨텐츠**: 이메일 템플릿의 경우 HTML 컨텐츠도 각 언어별로 관리됩니다

```typescript
const validateMultilingualContent = (content: MultilingualContent): boolean => {
  return content.ko.trim() !== '' && content.en.trim() !== '' && content.vi.trim() !== '';
};

const handleSave = () => {
  if (!validateMultilingualContent(content)) {
    // 안내 메시지 (다국어 적용 필요)
    showSnackbar('모든 언어에 대한 컨텐츠를 입력해주세요.', 'error');
    return;
  }
  // 저장 로직
};
```

#### Rich Text Editor (TinyMCE) Integration
이메일 템플릿 등 HTML 컨텐츠가 필요한 경우, 각 언어별로 독립적인 TinyMCE 에디터를 사용합니다:

```typescript
const [editorRefs, setEditorRefs] = useState<{
  ko: Editor | null;
  en: Editor | null;
  vi: Editor | null;
}>({
  ko: null,
  en: null,
  vi: null,
});

// 언어별 에디터 초기화
const handleEditorInit = (language: 'ko' | 'en' | 'vi', editor: Editor) => {
  setEditorRefs((prev) => ({
    ...prev,
    [language]: editor,
  }));
};

// 언어별 컨텐츠 가져오기
const getContent = (): MultilingualContent => {
  return {
    ko: editorRefs.ko?.getContent() || '',
    en: editorRefs.en?.getContent() || '',
    vi: editorRefs.vi?.getContent() || '',
  };
};

// UI 구조
<CustomTabPanel value={languageTab} index={0}>
  <Editor
    onInit={(evt, editor) => handleEditorInit('ko', editor)}
    initialValue={content.ko}
    init={editorConfig}
  />
</CustomTabPanel>
<CustomTabPanel value={languageTab} index={1}>
  <Editor
    onInit={(evt, editor) => handleEditorInit('en', editor)}
    initialValue={content.en}
    init={editorConfig}
  />
</CustomTabPanel>
<CustomTabPanel value={languageTab} index={2}>
  <Editor
    onInit={(evt, editor) => handleEditorInit('vi', editor)}
    initialValue={content.vi}
    init={editorConfig}
  />
</CustomTabPanel>
```

#### Storage Pattern
다국어 컨텐츠는 다음과 같은 형식으로 저장됩니다:

```typescript
// LocalStorage 예시
interface StoredTemplate {
  groupId: string;
  templateId: string;
  title: {
    ko: string;
    en: string;
    vi: string;
  };
  content: {
    ko: string;
    en: string;
    vi: string;
  };
}

// API 요청/응답 예시
interface APIRequest {
  title: MultilingualContent;
  content: MultilingualContent;
}

interface APIResponse {
  id: string;
  title: MultilingualContent;
  content: MultilingualContent;
  createdAt: string;
}
```

#### Page Titles and Fixed Text
모든 페이지의 제목, 설명, 그리고 고정된 문구들도 다국어로 관리되어야 합니다.

##### Page Text Management
- **페이지 제목**: 모든 페이지의 제목은 다국어로 관리됩니다
- **페이지 설명**: 페이지 제목 아래에 표시되는 설명도 다국어로 관리됩니다
- **고정된 문구**: 버튼 텍스트, 라벨, 플레이스홀더 등 모든 고정된 문구도 다국어로 관리됩니다

##### Implementation Pattern
페이지 제목과 설명은 `src/utils/pageTexts.ts` 파일에서 중앙 관리합니다:

```typescript
// src/utils/pageTexts.ts
import { MultilingualContent } from '../types/multilingual';

export interface PageTexts {
  title: MultilingualContent;
  description?: MultilingualContent;
}

export const pageTexts: Record<string, PageTexts> = {
  autoMail: {
    // 페이지 제목 (다국어)
    title: {
      ko: '자동 메일',
      en: 'Auto Mail',
      vi: 'Email tự động',
    },
    // 페이지 설명 (다국어)
    description: {
      ko: '사용자에게 자동으로 발송되는 이메일 템플릿 목록입니다.',
      en: 'List of email templates that are automatically sent to users.',
      vi: 'Danh sách các mẫu email được gửi tự động cho người dùng.',
    },
  },
  // ... 다른 페이지들
};

export const getPageText = (pageKey: string, language: 'ko' | 'en' | 'vi'): { title: string; description?: string } => {
  const pageText = pageTexts[pageKey];
  if (!pageText) {
    return { title: pageKey };
  }

  return {
    title: pageText.title[language],
    description: pageText.description?.[language],
  };
};
```

##### Usage in Pages
페이지 컴포넌트에서 다음과 같이 사용합니다:

```typescript
import { useLanguage } from '../context/LanguageContext';
import { getPageText, getCommonText } from '../utils/pageTexts';

const MyPage = () => {
  const { language } = useLanguage();
  const pageText = getPageText('myPage', language);

  return (
    <Box>
      {/* 페이지 제목 (다국어) */}
      <Typography variant="h4" gutterBottom>
        {pageText.title}
      </Typography>
      {/* 페이지 설명 (다국어) */}
      {pageText.description && (
        <Typography variant="subtitle1" color="text.secondary">
          {pageText.description}
        </Typography>
      )}
      {/* 버튼 텍스트 (다국어 적용 필요) */}
      <Button variant="contained">
        {getCommonText('save', language)}  {/* 저장 */}
      </Button>
      <Button variant="outlined">
        {getCommonText('cancel', language)}  {/* 취소 */}
      </Button>
      <Button variant="outlined" color="error">
        {getCommonText('delete', language)}  {/* 삭제 */}
      </Button>
      {/* 페이지 내용 */}
    </Box>
  );
};
```

##### Data Structure for Multilingual Content
더미데이터의 모든 텍스트 필드도 다국어로 관리됩니다:

```typescript
// 예시: MailTemplate 인터페이스
export interface MailTemplate {
  id: number | string;
  name: MultilingualContent;  // 템플릿 이름
  title?: MultilingualContent;  // 이메일 제목
  description?: MultilingualContent;  // 템플릿 설명
}

// 예시: MailGroup 인터페이스
export interface MailGroup {
  id: string;
  name: MultilingualContent;  // 그룹 이름
  templates: MailTemplate[];
}
```

##### Displaying Multilingual Content
다국어 컨텐츠를 표시할 때는 현재 언어에 맞게 표시해야 합니다:

```typescript
import { useLanguage } from '../context/LanguageContext';
import { getCommonText } from '../utils/pageTexts';

const MyComponent = () => {
  const { language } = useLanguage();

  return (
    <Box>
      {/* 템플릿 이름 표시 (다국어) */}
    <Typography>
      {typeof content.name === 'string'
        ? content.name
        : content.name[language]
      }
    </Typography>

      {/* 버튼 텍스트 (다국어 적용 필요) */}
      <Button variant="contained">
        {getCommonText('save', language)}  {/* 저장 */}
      </Button>
      <Button variant="outlined">
        {getCommonText('edit', language)}  {/* 수정 */}
      </Button>
      <Button variant="outlined" color="error">
        {getCommonText('delete', language)}  {/* 삭제 */}
      </Button>

      {/* 라벨 (다국어 적용 필요) */}
      <TextField
        label={getCommonText('emailAddress', language)}  {/* 이메일 주소 */}
        placeholder={getCommonText('emailAddress', language)}  {/* 플레이스홀더 (다국어 적용 필요) */}
        fullWidth
      />

      {/* 안내 메시지 (다국어 적용 필요) */}
      <Alert severity="info">
        {getCommonText('noRecipientsSelected', language)}  {/* 발송 대상이 선택되지 않았습니다. */}
      </Alert>
    </Box>
  );
};
```

##### Backward Compatibility
기존 단일 문자열 형식의 데이터를 다국어로 마이그레이션할 때는 하위 호환성을 고려해야 합니다:

```typescript
// 하위 호환성: 단일 문자열을 MultilingualContent로 변환
const migrateContent = (content: string | MultilingualContent): MultilingualContent => {
  if (typeof content === 'string') {
    return {
      ko: content,
      en: content,
      vi: content,
    };
  }
  return content;
};
```

##### Mock Data Guidelines
더미데이터를 작성할 때는 모든 텍스트 필드를 다국어로 작성해야 합니다:

```typescript
// 예시: 자동 메일 그룹 더미데이터
export const autoMailGroups: MailGroup[] = [
  {
    id: 'member',
    // 그룹 이름 (다국어)
    name: {
      ko: '회원',
      en: 'Member',
      vi: 'Thành viên',
    },
    templates: [
      {
        id: 1,
        // 템플릿 이름 (다국어)
        name: {
          ko: '가입 환영',
          en: 'Welcome',
          vi: 'Chào mừng',
        },
        // 이메일 제목 (다국어)
        title: {
          ko: '도토리에 오신 것을 환영합니다!',
          en: 'Welcome to Dotore!',
          vi: 'Chào mừng đến với Dotore!',
        },
        // 템플릿 설명 (다국어)
        description: {
          ko: '신규 회원 가입 시 자동으로 발송되는 환영 메일',
          en: 'Welcome email automatically sent when a new member joins',
          vi: 'Email chào mừng được gửi tự động khi thành viên mới tham gia',
        },
      },
      // ... 다른 템플릿들
    ],
  },
  // ... 다른 그룹들
];
```

**더미데이터 작성 규칙:**
- 모든 텍스트 필드는 `MultilingualContent` 타입으로 작성
- 한국어, 영어, 베트남어 모두 필수 입력
- 의미가 동일하도록 각 언어별로 적절히 번역
- 일관된 구조 유지

##### Key Points
- **페이지 제목/설명**: `pageTexts.ts`에서 중앙 관리
- **더미데이터**: 모든 텍스트 필드를 `MultilingualContent` 타입으로 변경
- **표시 로직**: 현재 언어에 맞게 표시 (하위 호환성 고려)
- **하위 호환성**: 기존 단일 문자열 데이터를 자동으로 다국어로 변환
- **일관성**: 모든 더미데이터는 동일한 다국어 구조를 따름

#### Key Points
- **필수 다국어 지원**: 모든 사용자 노출 컨텐츠는 3개 언어(한국어, 영어, 베트남어) 모두 필수
- **탭 기반 UI**: 언어별 입력을 위해 탭 인터페이스 사용
- **GNB 언어 연동**: GNB에서 설정한 언어에 따라 해당 언어 탭이 자동으로 선택됨
- **독립적인 에디터**: HTML 컨텐츠의 경우 각 언어별로 독립적인 에디터 인스턴스 사용
- **검증 필수**: 저장 전 모든 언어에 대한 컨텐츠 입력 검증
- **일관된 구조**: 모든 다국어 컨텐츠는 동일한 `MultilingualContent` 타입 사용
- **페이지 제목/설명**: 모든 페이지의 제목과 설명도 다국어로 관리
- **고정된 문구**: 버튼, 라벨, 플레이스홀더 등 모든 고정된 문구도 다국어로 관리

#### Summary
- **지원 언어**: 한국어(ko), 영어(en), 베트남어(vi)
- **적용 대상**:
  - 공지사항, 이벤트, 이메일 템플릿 등 모든 사용자 노출 컨텐츠
  - 페이지 제목, 페이지 설명
  - 템플릿 그룹 이름, 템플릿 이름, 이메일 제목, 템플릿 설명
  - 버튼 텍스트, 라벨, 플레이스홀더 등 모든 고정된 문구
- **데이터 구조**: `MultilingualContent` 인터페이스로 통일
- **UI 패턴**: 탭 기반 인터페이스로 언어별 입력
- **GNB 연동**: GNB 언어 설정에 따라 탭 자동 선택 및 모든 텍스트 자동 변경
- **검증**: 저장 전 모든 언어 입력 필수 검증
- **에디터**: HTML 컨텐츠는 언어별 독립적인 에디터 인스턴스 사용
- **페이지 텍스트**: `pageTexts.ts`에서 중앙 관리
- **하위 호환성**: 기존 단일 문자열 데이터를 자동으로 다국어로 변환

## Common Patterns

### Snackbar Usage
```typescript
import { useSnackbar } from '../context/SnackbarContext';

const { showSnackbar } = useSnackbar();
// 안내 메시지 (다국어 적용 필요)
showSnackbar('Message', 'success', 5000);
```

### Snackbar Design Guidelines
스낵바 컴포넌트는 어떤 페이지에 종속되어서는 안 되며, 페이지 전환 후에도 계속 노출되어야 합니다.

#### Global Snackbar Rules
- **페이지 독립성**: 스낵바 컴포넌트는 특정 페이지 컴포넌트 내부에 배치하지 않습니다
- **전역 관리**: Context API를 사용하여 전역 상태로 관리합니다
- **페이지 전환 지속성**: 페이지가 전환되어도 스낵바는 계속 표시되어야 합니다
- **Router 내부 배치**: Provider는 Router 내부에 배치하여 `useNavigate` 사용이 가능하도록 합니다

#### Implementation Pattern
1. **Context API를 사용한 전역 스낵바 관리**
   ```typescript
   // src/context/SendingStatusContext.tsx
   export const SendingStatusProvider = ({ children }: { children: React.ReactNode }) => {
     const [status, setStatus] = useState<SendingStatus>(null);
     const [open, setOpen] = useState(false);

     // 상태 관리 로직...

     return (
       <SendingStatusContext.Provider value={{ showSendingStatus, updateSendingStatus, closeSendingStatus }}>
         {children}
         <SendingStatusSnackbar
           open={open}
           status={status}
           onClose={closeSendingStatus}
         />
       </SendingStatusContext.Provider>
     );
   };
   ```

2. **App.tsx에 Provider 배치**
   ```typescript
   // Router 내부에 Provider 배치 (useNavigate 사용을 위해)
   <Router>
     <SendingStatusProvider>
       <Routes>
         {/* routes */}
       </Routes>
     </SendingStatusProvider>
   </Router>
   ```

3. **페이지에서 Context 사용**
   ```typescript
   // 페이지 컴포넌트 내부
   import { useSendingStatus } from '../context/SendingStatusContext';

   const { showSendingStatus, updateSendingStatus } = useSendingStatus();

   const handleSend = async () => {
     showSendingStatus();
     updateSendingStatus('request');
     // ... 로직
     updateSendingStatus('sending');
     // ... 로직
     updateSendingStatus('completed');
   };
   ```

#### Snackbar Styling Guidelines
모든 스낵바는 일관된 스타일을 유지해야 하며, 배경색이 밝을 때도 잘 보이도록 진한 색상을 사용해야 합니다.

##### Color Styling
- **모든 severity에 진한 색상 적용**: 성공, 실패, 경고, 정보 스낵바 모두 테마의 `main` 색상과 `contrastText`를 사용하여 가독성을 보장합니다
- **배경색**: 각 severity의 `main` 색상 사용 (예: `success.main`, `error.main`, `warning.main`, `info.main`)
- **텍스트 색상**: 각 severity의 `contrastText` 사용 (예: `success.contrastText`, `error.contrastText`)
- **아이콘 색상**: 텍스트 색상과 동일하게 `contrastText` 사용

```typescript
<Alert
  severity={snackbar.severity}
  sx={{
    width: '100%',
    // 모든 severity에 대해 진한 색상 적용 (배경색이 밝을 때도 잘 보이도록)
    ...(snackbar.severity === 'success' && {
      bgcolor: 'success.main',
      color: 'success.contrastText',
      '& .MuiAlert-icon': {
        color: 'success.contrastText',
      },
    }),
    ...(snackbar.severity === 'error' && {
      bgcolor: 'error.main',
      color: 'error.contrastText',
      '& .MuiAlert-icon': {
        color: 'error.contrastText',
      },
    }),
    ...(snackbar.severity === 'warning' && {
      bgcolor: 'warning.main',
      color: 'warning.contrastText',
      '& .MuiAlert-icon': {
        color: 'warning.contrastText',
      },
    }),
    ...(snackbar.severity === 'info' && {
      bgcolor: 'info.main',
      color: 'info.contrastText',
      '& .MuiAlert-icon': {
        color: 'info.contrastText',
      },
    }),
  }}
>
  {snackbar.message}
</Alert>
```

##### Position Styling
- **기본 위치**: 중앙 하단 (`anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}`)
- **커스텀 위치 불필요**: MUI의 기본 `anchorOrigin` 속성만 사용하며, 추가적인 `sx` 스타일로 위치를 오버라이드하지 않습니다
- **일관성 유지**: 모든 스낵바는 동일한 위치에 표시되어야 합니다

```typescript
<Snackbar
  open={snackbar.open}
  autoHideDuration={snackbar.duration}
  onClose={handleClose}
  anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
>
  {/* Alert 컴포넌트 */}
</Snackbar>
```

##### Key Points
- **진한 색상 필수**: 배경색이 밝을 때도 스낵바가 잘 보이도록 `main` 색상과 `contrastText` 사용
- **모든 severity 지원**: success, error, warning, info 모두 동일한 스타일 패턴 적용
- **중앙 하단 위치**: 기본적으로 중앙 하단에 표시되며, 별도 옵션 없이는 이 위치를 유지
- **일관된 스타일**: 모든 스낵바는 동일한 스타일 규칙을 따름

#### Status-Based Snackbar (발송 상태 스낵바)
발송 상태와 같은 단계별 프로세스를 표시하는 스낵바는 다음과 같은 패턴을 따릅니다:

- **상태 단계**: `request` → `sending` → `completed`
- **UI 표시 위치**: 화면 우측 하단 고정
- **로딩 애니메이션**: `sending` 상태일 때 `CircularProgress` 표시
- **완료 후 액션**: `completed` 상태일 때 추가 액션 버튼 (예: "발송 이력 보기") 표시 (버튼 텍스트는 다국어 적용 필요)

#### Key Points
- **Provider 위치**: Router 내부에 배치하여 Router 컨텍스트 접근 가능
- **컴포넌트 위치**: 스낵바 컴포넌트는 Provider 내부에서 렌더링
- **상태 관리**: Context를 통해 전역 상태로 관리
- **페이지 전환**: 페이지 전환 시 스낵바 상태 유지
- **자동 닫기**: `sending` 상태일 때는 자동 닫기 방지

#### Summary
- **전역 관리**: Context API로 전역 상태 관리
- **페이지 독립**: 페이지 컴포넌트에 종속되지 않음
- **지속성**: 페이지 전환 후에도 계속 표시
- **Router 내부**: Provider는 Router 내부에 배치
- **상태 기반**: 단계별 상태에 따른 UI 변경 지원
- **스타일 일관성**: 모든 severity(success, error, warning, info)에 진한 색상 적용
- **위치 고정**: 기본적으로 중앙 하단에 표시 (`anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}`)

### Navigation
```typescript
const navigate = useNavigate();
navigate('/auto-mail');
```

### Local Storage
```typescript
import { saveTemplate, getTemplate } from '../utils/storage';
saveTemplate(groupId, templateId, title, content);
const template = getTemplate(groupId, templateId);
```

### Theme Usage
```typescript
const theme = useTheme();
// Or in sx prop: sx={{ color: 'primary.main' }}
```

### Query Parameters for Search, Filtering, and Table State
검색 기능, 필터링 기능, 테이블 컴포넌트가 있는 페이지는 쿼리 파라미터를 통해 상태를 URL에 저장하고 공유할 수 있어야 합니다.

#### When to Use Query Parameters
- 검색 기능이 있는 페이지
- 필터링 기능이 있는 페이지
- 테이블 컴포넌트가 있는 페이지 (페이지네이션 포함)
- 탭 기반 UI가 있는 페이지
- 상세 모달을 열 수 있는 페이지

#### Implementation Pattern
1. **Import Required Hooks**
   ```typescript
   import { useEffect } from 'react';
   import { useSearchParams } from 'react-router-dom';
   ```

2. **Initialize State and Query Parameters**
   ```typescript
   const [searchParams, setSearchParams] = useSearchParams();
   const [isInitialized, setIsInitialized] = useState(false);

   // 페이지 상태들
   const [tabValue, setTabValue] = useState<number>(0);
   const [searchQuery, setSearchQuery] = useState<string>('');
   const [searchType, setSearchType] = useState<string>('all');
   const [filter1, setFilter1] = useState<string>('all');
   const [page, setPage] = useState<number>(0);
   const [rowsPerPage, setRowsPerPage] = useState<number>(10);
   ```

3. **Read Initial Values from URL Parameters (One-time)**
   ```typescript
   useEffect(() => {
     if (isInitialized) return; // 이미 초기화되었으면 실행하지 않음

     // URL 파라미터 읽기
     const tabParam = searchParams.get('tab');
     const searchParam = searchParams.get('search');
     const searchTypeParam = searchParams.get('searchType');
     const filter1Param = searchParams.get('filter1');
     const pageParam = searchParams.get('page');
     const rowsPerPageParam = searchParams.get('rowsPerPage');
     const itemIdParam = searchParams.get('itemId'); // 상세 모달용

     // itemId 파라미터가 있으면 해당 항목을 찾아서 모달 열기
     if (itemIdParam) {
       const item = items.find((item) => item.id === itemIdParam);
       if (item) {
         setSelectedItem(item);
         setOpenModal(true);
         // URL에서 itemId 파라미터 제거
         const newParams = new URLSearchParams(searchParams);
         newParams.delete('itemId');
         setSearchParams(newParams, { replace: true });
       }
     }

     // URL 파라미터에서 초기값 설정
     if (tabParam) {
       const tabIndex = tabParam === 'tab1' ? 0 : tabParam === 'tab2' ? 1 : 0;
       setTabValue(tabIndex);
     }
     if (searchParam !== null) {
       setSearchQuery(searchParam);
     }
     if (searchTypeParam) {
       setSearchType(searchTypeParam);
     }
     if (filter1Param) {
       setFilter1(filter1Param);
     }
     if (pageParam) {
       const pageNum = parseInt(pageParam, 10);
       if (!isNaN(pageNum)) {
         setPage(pageNum);
       }
     }
     if (rowsPerPageParam) {
       const rowsNum = parseInt(rowsPerPageParam, 10);
       if (!isNaN(rowsNum)) {
         setRowsPerPage(rowsNum);
       }
     }

     setIsInitialized(true);
   }, [isInitialized, searchParams, setSearchParams, items]);
   ```

4. **Update URL Parameters When State Changes**
   ```typescript
   useEffect(() => {
     if (!isInitialized) return; // 초기화되지 않았으면 실행하지 않음

     const newParams = new URLSearchParams();

     // 탭 선택
     if (tabValue === 0) {
       newParams.set('tab', 'tab1');
     } else if (tabValue === 1) {
       newParams.set('tab', 'tab2');
     }

     // 검색 관련
     if (searchQuery) {
       newParams.set('search', searchQuery);
     }
     if (searchType !== 'all') {
       newParams.set('searchType', searchType);
     }

     // 필터
     if (filter1 !== 'all') {
       newParams.set('filter1', filter1);
     }

     // 페이지네이션
     if (page !== 0) {
       newParams.set('page', String(page));
     }
     if (rowsPerPage !== 10) {
       newParams.set('rowsPerPage', String(rowsPerPage));
     }

     // 현재 URL과 비교하여 변경사항이 있을 때만 업데이트
     const currentParams = searchParams.toString();
     const newParamsStr = newParams.toString();

     if (currentParams !== newParamsStr) {
       setSearchParams(newParams, { replace: true });
     }
   }, [
     tabValue,
     searchQuery,
     searchType,
     filter1,
     page,
     rowsPerPage,
     isInitialized,
     searchParams,
     setSearchParams,
   ]);
   ```

#### Key Points
- **isInitialized 플래그**: 초기화가 한 번만 실행되도록 보장
- **replace: true**: 브라우저 히스토리에 불필요한 항목이 쌓이지 않도록 함
- **조건부 업데이트**: 기본값이 아닌 경우에만 URL 파라미터에 추가
- **변경사항 체크**: 현재 URL과 비교하여 실제 변경사항이 있을 때만 업데이트
- **상세 모달**: `itemId` 파라미터를 통해 특정 항목의 상세 모달을 자동으로 열 수 있음

#### Example: Tab-Based UI with Multiple Pagination States
탭 기반 UI에서 각 탭마다 독립적인 페이지네이션 상태를 가질 때:

```typescript
// 각 탭별 페이지네이션 상태
const [autoPage, setAutoPage] = useState<number>(0);
const [autoRowsPerPage, setAutoRowsPerPage] = useState<number>(10);
const [manualPage, setManualPage] = useState<number>(0);
const [manualRowsPerPage, setManualRowsPerPage] = useState<number>(10);

// URL 파라미터 읽기
useEffect(() => {
  if (isInitialized) return;

  const autoPageParam = searchParams.get('autoPage');
  const autoRowsPerPageParam = searchParams.get('autoRowsPerPage');
  const manualPageParam = searchParams.get('manualPage');
  const manualRowsPerPageParam = searchParams.get('manualRowsPerPage');

  if (autoPageParam) {
    const pageNum = parseInt(autoPageParam, 10);
    if (!isNaN(pageNum)) {
      setAutoPage(pageNum);
    }
  }
  // ... 다른 파라미터들

  setIsInitialized(true);
}, [isInitialized, searchParams, setSearchParams]);

// URL 파라미터 업데이트
useEffect(() => {
  if (!isInitialized) return;

  const newParams = new URLSearchParams();

  if (autoPage !== 0) {
    newParams.set('autoPage', String(autoPage));
  }
  if (autoRowsPerPage !== 10) {
    newParams.set('autoRowsPerPage', String(autoRowsPerPage));
  }
  if (manualPage !== 0) {
    newParams.set('manualPage', String(manualPage));
  }
  if (manualRowsPerPage !== 10) {
    newParams.set('manualRowsPerPage', String(manualRowsPerPage));
  }

  // ... 변경사항 체크 및 업데이트
}, [autoPage, autoRowsPerPage, manualPage, manualRowsPerPage, isInitialized, searchParams, setSearchParams]);
```

#### Summary
- **검색/필터/테이블 페이지**: 항상 쿼리 파라미터 지원 구현
- **isInitialized 플래그**: 초기화 한 번만 실행
- **조건부 업데이트**: 기본값이 아닌 경우에만 URL에 추가
- **변경사항 체크**: 실제 변경이 있을 때만 업데이트
- **상세 모달**: itemId 파라미터로 자동 열기 지원

## Anti-Patterns to Avoid
- Don't use `any` type - use proper types
- Don't mix controlled and uncontrolled components
- Don't create Context without Provider
- Don't use inline styles - use `sx` prop
- Don't mutate state directly - use setState
- Don't forget dependency arrays in useEffect
- Don't use `var` - use `const` or `let`
- Don't create functions in JSX without useCallback when passed to memoized components
- **Don't use hardcoded colors** - always use theme colors for dark mode compatibility
- **Don't assume light mode only** - all styling must work in both light and dark modes

## Code Formatting
- Use 2 spaces for indentation
- Use single quotes for strings (TypeScript/JavaScript)
- Use trailing commas in multi-line objects/arrays
- Use semicolons
- Maximum line length: 120 characters (soft limit)

## When Adding New Features
1. Check if similar functionality exists
2. Follow existing patterns and conventions
3. Create reusable components when appropriate
4. Add TypeScript types for new data structures
5. Update Context if global state is needed
6. Use existing utility functions when possible
7. Test with Korean (IME) input when applicable
8. **Test in both light and dark modes** - All UI changes must be verified in both modes
