---
alwaysApply: true
---

# Cursor Rules for Dotore Admin Project

## Project Overview
This is a React 19 + TypeScript admin dashboard application using Material-UI (MUI), React Router, and TinyMCE. The project follows a component-based architecture with Context API for global state management.

## Tech Stack
- **Framework**: React 19.2.0 with TypeScript 5.9.3
- **Build Tool**: Vite 7.2.2
- **UI Library**: Material-UI (MUI) 7.3.5
- **Routing**: React Router DOM 7.9.6
- **Rich Text Editor**: TinyMCE 8.2.2 (@tinymce/tinymce-react 6.3.0)
- **State Management**: React Context API
- **Styling**: Emotion (via MUI), CSS-in-JS with `sx` prop

## Project Structure

```
src/
├── components/     # Reusable UI components
├── pages/          # Page-level components (routes)
├── context/        # React Context providers
├── utils/          # Utility functions
├── types/          # TypeScript type definitions
├── themes/         # MUI theme customization
└── data/           # Mock data and constants
```

## Page Structure

애플리케이션의 페이지 구조는 다음과 같이 계층적으로 구성되어 있습니다:

### 인증 전 페이지 (Public Routes)
- **`/login`** - `LoginPage.tsx`
  - 로그인 페이지 (인증 필요 없음)

### 인증 후 페이지 (Private Routes - Layout 내부)
모든 인증 후 페이지는 `Layout` 컴포넌트로 감싸져 있으며, 사이드바와 상단 네비게이션을 포함합니다.

#### 메인 페이지
- **`/`** (index) - `InquiryListPage.tsx`
  - 문의 목록 페이지 (기본 페이지)

#### 문의 관리
- **`/analysis`** - `InquiryAnalysisPage.tsx`
  - 문의 분석 페이지
  - 상위: `/` (문의 목록)

#### 자동 메일 관리
- **`/auto-mail`** - `AutoMailPage.tsx`
  - 자동 메일 그룹 및 템플릿 목록 페이지
- **`/auto-mail/:groupId/:templateId`** - `MailTemplatePage.tsx`
  - 자동 메일 템플릿 편집 페이지
  - 상위: `/auto-mail` (자동 메일 목록)
  - 동적 라우트: `groupId`, `templateId` 파라미터 사용

#### 수동 메일 관리
- **`/manual-mail`** - `ManualMailPage.tsx`
  - 수동 메일 그룹 및 템플릿 목록 페이지
- **`/manual-mail/:groupId/:templateId`** - `MailTemplatePage.tsx`
  - 수동 메일 템플릿 편집 페이지
  - 상위: `/manual-mail` (수동 메일 목록)
  - 동적 라우트: `groupId`, `templateId` 파라미터 사용

### 페이지 계층 구조 요약
```
/login (인증 전)
  └─ LoginPage

/ (인증 후 - Layout)
  ├─ / (index)
  │  └─ InquiryListPage
  │
  ├─ /analysis
  │  └─ InquiryAnalysisPage
  │     └─ 상위: InquiryListPage
  │
  ├─ /auto-mail
  │  └─ AutoMailPage
  │     └─ /auto-mail/:groupId/:templateId
  │        └─ MailTemplatePage
  │           └─ 상위: AutoMailPage
  │
  └─ /manual-mail
     └─ ManualMailPage
        └─ /manual-mail/:groupId/:templateId
           └─ MailTemplatePage
              └─ 상위: ManualMailPage
```

### 페이지 파일 위치
모든 페이지 컴포넌트는 `src/pages/` 디렉토리에 위치합니다:
- `LoginPage.tsx`
- `InquiryListPage.tsx`
- `InquiryAnalysisPage.tsx`
- `AutoMailPage.tsx`
- `ManualMailPage.tsx`
- `MailTemplatePage.tsx`

## Code Style & Conventions

### TypeScript
- Use strict TypeScript with explicit types
- Prefer interfaces for object shapes, types for unions/intersections
- Use `as const` for literal types when needed (e.g., TinyMCE menu items)
- Avoid `any` - use `unknown` or proper types instead
- Use type assertions sparingly and only when necessary

### React Patterns
- Use functional components with hooks
- Prefer named exports for components
- Use `React.useRef` for DOM references and mutable values
- Use `React.useState` for local component state
- Use `React.useEffect` with proper dependency arrays
- Use `React.useCallback` and `React.useMemo` for performance optimization when needed

### Tab-Based UI Patterns
탭 기반 UI를 구현할 때는 각 탭마다 완전히 독립적인 컴포넌트와 로직을 사용해야 합니다.

#### Tab Panel Structure
- MUI의 `Tabs`와 `Tab` 컴포넌트를 사용합니다
- 각 탭의 내용은 `CustomTabPanel` 컴포넌트로 감싸서 독립적으로 관리합니다
- `CustomTabPanel`은 `hidden` 속성과 조건부 렌더링을 사용하여 탭 전환을 처리합니다

Example pattern:
```typescript
interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function CustomTabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`tabpanel-${index}`}
      aria-labelledby={`tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 0 }}>{children}</Box>}
    </div>
  );
}
```

#### Independent State Management
- **각 탭마다 독립적인 상태를 사용합니다**
  - 하나의 공유 상태를 값만 변경해서 사용하지 않습니다
  - 각 탭마다 별도의 `useState`로 페이지네이션 상태를 관리합니다
  - 예: `autoPage`, `manualPage`, `recipientPage` (각각 독립적인 상태)

#### Independent Handler Functions
- **각 탭마다 독립적인 핸들러 함수를 사용합니다**
  - 공유 핸들러 함수를 사용하지 않습니다
  - 각 탭마다 별도의 핸들러 함수를 정의합니다
  - 예: `handleAutoPageChange`, `handleManualPageChange`, `handleRecipientPageChange`

#### Independent Logic Separation
- **각 탭마다 독립적인 필터링 및 페이지네이션 로직을 사용합니다**
  - 하나의 공유 로직을 조건문으로 분기하지 않습니다
  - 각 탭마다 별도의 `useMemo`로 필터링 및 페이지네이션을 처리합니다
  - 예: `autoFiltered`, `autoPaginated`, `manualFiltered`, `manualPaginated`, `recipientFiltered`, `recipientPaginated`

#### Independent Table Components
- **각 탭마다 독립적인 테이블 컴포넌트를 사용합니다**
  - 하나의 테이블 컴포넌트를 값만 변경해서 재사용하지 않습니다
  - 각 탭의 `CustomTabPanel` 내부에 완전히 독립적인 `Table` 컴포넌트를 배치합니다
  - 각 테이블은 자신만의 헤더, 바디, 페이지네이션을 가집니다

Example structure:
```typescript
<CustomTabPanel value={tabValue} index={0}>
  <TableContainer>
    <Table stickyHeader>
      {/* 자동 탭 전용 테이블 */}
    </Table>
  </TableContainer>
  {/* 자동 탭 전용 페이지네이션 */}
</CustomTabPanel>

<CustomTabPanel value={tabValue} index={1}>
  <TableContainer>
    <Table stickyHeader>
      {/* 수동 탭 전용 테이블 */}
    </Table>
  </TableContainer>
  {/* 수동 탭 전용 페이지네이션 */}
</CustomTabPanel>
```

#### Summary
- **독립적인 상태**: 각 탭마다 별도의 `useState` 사용
- **독립적인 핸들러**: 각 탭마다 별도의 핸들러 함수 정의
- **독립적인 로직**: 각 탭마다 별도의 `useMemo`로 필터링/페이지네이션 처리
- **독립적인 테이블**: 각 탭마다 별도의 `Table` 컴포넌트 사용
- **공유하지 않음**: 하나의 컴포넌트/함수/상태를 값만 변경해서 재사용하지 않음

### Component Organization
- **Components** (`src/components/`): Reusable, presentational components
- **Pages** (`src/pages/`): Route-level components that compose multiple components
- **Context** (`src/context/`): Global state providers with custom hooks
- Each component should be in its own file with matching name

### Naming Conventions
- **Components**: PascalCase (e.g., `MailTemplatePage.tsx`)
- **Files**: Match component name (e.g., `Layout.tsx` for `Layout` component)
- **Hooks**: Start with `use` (e.g., `useSnackbar`, `useLanguage`)
- **Context**: PascalCase with `Context` suffix (e.g., `SnackbarContext`)
- **Types/Interfaces**: PascalCase (e.g., `MailTemplate`, `Language`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `AVAILABLE_VARIABLES`)
- **Functions**: camelCase (e.g., `handleSave`, `getTemplate`)

### MUI Usage
- Always import MUI components from `@mui/material` or `@mui/icons-material`
- Use the `sx` prop for styling instead of `style` prop
- Use theme-aware values in `sx` (e.g., `'primary.main'`, `'text.secondary'`)
- Prefer MUI components over native HTML elements when possible
- Use `styled` API for complex reusable styled components
- Use `useTheme` hook when theme values are needed in JavaScript

### Context API Patterns
- Create Context files in `src/context/` directory
- Export a Provider component and a custom hook (e.g., `useSnackbar`)
- Provider should wrap the entire app in `App.tsx`
- Custom hook should throw error if used outside provider
- Use `useCallback` for context functions to prevent unnecessary re-renders

Example pattern:
```typescript
const Context = createContext<ContextType | undefined>(undefined);

export const useContext = () => {
  const context = useContext(Context);
  if (!context) {
    throw new Error('useContext must be used within Provider');
  }
  return context;
};

export const Provider = ({ children }: { children: React.ReactNode }) => {
  // implementation
  return <Context.Provider value={value}>{children}</Context.Provider>;
};
```

### Routing
- Use React Router DOM v7 patterns
- Define routes in `App.tsx`
- Use `useNavigate` for programmatic navigation
- Use `useLocation` for current route information
- Use `useParams` for route parameters
- Use `Link` component for navigation links

### TinyMCE Integration
- Use `@tinymce/tinymce-react` Editor component
- Keep editor as uncontrolled component (use `initialValue`, not `value`)
- Use `onInit` to get editor reference
- Use `onEditorChange` sparingly to avoid cursor issues with IME input
- Retrieve content with `editorRef.current.getContent()` when needed
- Use `editor.getContent({ format: 'text' })` to get plain text

### State Management
- **Local State**: Use `useState` for component-specific state
- **Global State**: Use Context API (ColorMode, Language, Snackbar)
- **Persistent State**: Use `localStorage` via utility functions in `src/utils/storage.ts`
- Avoid prop drilling - use Context when state is needed across multiple components

### Styling Guidelines
- Use MUI's `sx` prop for component-level styles
- Use theme spacing units (e.g., `sx={{ p: 3, mb: 2 }}`)
- Use theme colors (e.g., `'primary.main'`, `'error.lighter'`)
- Use responsive breakpoints when needed
- Keep styles co-located with components
- Use `styled` API for complex reusable styled components
- **Dark Mode Compatibility**: Always ensure CSS/styling works in both light and dark modes
  - Never use hardcoded colors (e.g., `#ffffff`, `#000000`) - use theme colors instead
  - Use theme-aware color values: `'text.primary'`, `'text.secondary'`, `'background.paper'`, `'background.default'`
  - Use `'divider'` for borders instead of hardcoded gray colors
  - When using custom colors, provide both light and dark variants in theme palette
  - Test all styling changes in both light and dark modes
  - Use `useTheme()` hook or theme-aware `sx` prop values for dynamic color selection
  - For custom CSS (if necessary), use CSS variables or theme-aware selectors

### Table Design Guidelines
모든 테이블은 일관된 디자인을 유지해야 합니다. 문의 목록 테이블(`InquiryListPage.tsx`)의 스타일 규칙을 표준으로 따릅니다.

#### Table Container & Wrapper
- 테이블은 `Paper` 컴포넌트로 감싸야 합니다
- Paper 스타일:
  ```typescript
  <Paper
    sx={{
      width: '100%',
      borderRadius: 2,
      border: '1px solid',
      borderColor: 'divider',
      boxShadow: 'none',
    }}
  >
    {/* 테이블 내용 */}
  </Paper>
  ```
- `TableContainer`는 Paper 없이 직접 사용합니다 (Paper 내부에 위치)

#### Table Structure
- `Table` 컴포넌트에 `stickyHeader` 속성을 항상 사용합니다
  ```typescript
  <Table stickyHeader>
  ```

#### Table Head (헤더)
- `TableCell` 헤더에는 `fontWeight`를 명시하지 않습니다 (기본 스타일 사용)
- 모든 헤더 셀에 `whiteSpace: 'nowrap'`을 사용합니다
- 필요시 `width`, `minWidth` 속성을 사용하여 컬럼 너비를 지정합니다
  ```typescript
  <TableCell sx={{ whiteSpace: 'nowrap' }}>헤더 텍스트</TableCell>
  // 또는
  <TableCell sx={{ width: '100px', minWidth: '100px', whiteSpace: 'nowrap' }}>헤더 텍스트</TableCell>
  ```

#### Table Body (바디)
- 모든 바디 셀에 `whiteSpace: 'nowrap'`을 사용합니다
- 셀 내부 텍스트는 `Typography` 컴포넌트로 감싸고 `variant="body2"`를 사용합니다
- 기본 텍스트: `variant="body2"` (색상 없음, 기본 `text.primary`)
- 보조 텍스트: `variant="body2" color="text.secondary"`
- 모든 텍스트에 `noWrap` 속성을 추가합니다
  ```typescript
  <TableCell sx={{ whiteSpace: 'nowrap' }}>
    <Typography variant="body2" noWrap>
      기본 텍스트
    </Typography>
  </TableCell>
  <TableCell sx={{ whiteSpace: 'nowrap' }}>
    <Typography variant="body2" color="text.secondary" noWrap>
      보조 텍스트
    </Typography>
  </TableCell>
  ```

#### Empty State (빈 데이터)
- 빈 데이터 셀은 `colSpan`을 사용하여 전체 컬럼을 차지합니다
- `align="center"`와 `sx={{ py: 8 }}`을 사용합니다
- `Box`로 감싸서 `Typography`를 사용합니다
  ```typescript
  <TableRow>
    <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 1 }}>
        <Typography variant="h6" color="text.secondary">
          조회된 데이터가 없습니다.
        </Typography>
      </Box>
    </TableCell>
  </TableRow>
  ```

#### Table Row
- 데이터 행에는 `hover` 속성을 사용합니다
- 클릭 가능한 행은 `sx={{ cursor: 'pointer' }}`를 추가합니다

#### Summary
- **Paper로 감싸기**: 항상 Paper 컴포넌트로 테이블을 감싸고 표준 스타일 적용
- **stickyHeader**: 모든 Table에 stickyHeader 속성 사용
- **whiteSpace: 'nowrap'**: 모든 TableCell에 적용
- **Typography variant="body2"**: 모든 셀 텍스트에 사용
- **noWrap**: 모든 Typography에 적용
- **헤더 fontWeight**: 명시하지 않음 (기본 스타일)
- **빈 데이터**: py: 8, Box로 감싸서 Typography 사용

### Date Format Guidelines
모든 날짜 표시는 **YY-MM-DD** 형식을 사용해야 합니다.

#### Date Format Rules
- **표준 형식**: `YY-MM-DD` (연도 2자리, 월 2자리, 일 2자리)
  - 예: `24-01-15` (2024년 1월 15일)
  - 예: `23-12-31` (2023년 12월 31일)
- 날짜만 표시할 때는 `YY-MM-DD` 형식을 사용합니다
- 시간이 필요한 경우 시간은 별도로 표시하거나 `YY-MM-DD HH:MM` 형식을 사용할 수 있습니다
- CSV 내보내기 시에도 동일한 형식을 사용합니다

#### Date Formatting Function Example
```typescript
const formatDateOnly = (dateString: string) => {
  const date = new Date(dateString);
  const year = String(date.getFullYear()).slice(-2);
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};
```

#### Time Formatting Function Example (if needed)
```typescript
const formatTimeOnly = (dateString: string) => {
  const date = new Date(dateString);
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${hours}:${minutes}`;
};
```

#### Summary
- **날짜 형식**: 항상 `YY-MM-DD` 형식 사용
- **월/일**: 항상 2자리로 표시 (padStart 사용)
- **연도**: 마지막 2자리만 표시 (slice(-2) 사용)
- **일관성**: 모든 페이지에서 동일한 형식 유지

### Auto Mail (자동 메일) Design Guidelines
자동 메일 발송은 시스템에서 자동으로 처리되므로, UI 설계 시 다음과 같은 특성을 고려해야 합니다.

#### Auto Mail Characteristics
- **자동 발송**: 시스템에서 자동으로 발송되므로 발송자 정보가 없습니다
- **사용자별 발송 시간**: 각 사용자의 상황에 따라 발송 시간이 다릅니다
- **고정된 발송일 없음**: 전체 발송에 대한 고정된 발송일이 없습니다

#### Auto Mail Table Design Rules
자동 메일 발송 이력 테이블에는 다음 컬럼만 표시해야 합니다:
- 템플릿 이름
- 그룹 이름
- 수신자 수
- 발송 성공
- 발송 실패

**제외해야 할 컬럼:**
- ❌ **상태 컬럼**: 자동 메일 테이블에는 상태 컬럼을 표시하지 않습니다
- ❌ **발송자 컬럼**: 시스템에서 자동으로 발송되므로 발송자 정보가 필요 없습니다
- ❌ **유형 컬럼**: 자동 탭에만 있으므로 유형 정보가 중복됩니다
- ❌ **발송일 컬럼**: 자동 발송은 사용자마다 발송 시간이 다르므로 고정된 발송일이 없습니다

#### Auto Mail Date Display
- **메인 테이블**: 자동 발송의 경우 발송일 셀에 `'-'`를 표시합니다
  ```typescript
  {item.type === 'auto' ? '-' : formatDateOnly(item.sentAt)}
  ```
- **수신자 목록**: 각 수신자별로 실제 발송 시간을 표시합니다 (수신자마다 발송 시간이 다름)

#### Auto Mail Data Structure
- 자동 발송 메일의 `sentAt` 필드는 전체 발송의 기준 시간일 수 있지만, 실제로는 각 수신자마다 다른 시간에 발송됩니다
- `successfulRecipients`와 `failedRecipients` 배열의 각 항목은 개별 발송 시간(`sentAt`)을 가집니다

#### Summary
- **자동 메일 테이블**: 템플릿 이름, 그룹 이름, 수신자 수, 발송 성공, 발송 실패만 표시
- **발송일 표시**: 메인 테이블에서는 `'-'` 표시, 수신자 목록에서는 개별 발송 시간 표시
- **발송자 정보**: 자동 발송은 시스템에서 처리되므로 발송자 정보 불필요
- **상태 정보**: 자동 메일 테이블에는 상태 컬럼 제외

### Error Handling
- Use try-catch for async operations
- Display user-friendly error messages via Snackbar
- Log errors to console for debugging
- Validate inputs before processing

### File Imports
- Group imports: external libraries, MUI components, internal components, utilities, types
- Use absolute imports from `src/` (e.g., `import { useSnackbar } from '../context/SnackbarContext'`)
- Use named imports for MUI components
- Use default imports for React Router hooks

### Performance
- Use `React.memo` for expensive components that re-render frequently
- Use `useCallback` for functions passed as props to memoized components
- Use `useMemo` for expensive computations
- Lazy load heavy components when appropriate
- Avoid creating functions/objects in render without memoization

### Accessibility
- Use semantic HTML elements
- Add `aria-label` to icon-only buttons
- Ensure keyboard navigation works
- Use MUI components which have built-in accessibility

### Testing Considerations
- Write testable components (pure functions when possible)
- Keep business logic separate from UI logic
- Use dependency injection for external services

## Common Patterns

### Snackbar Usage
```typescript
import { useSnackbar } from '../context/SnackbarContext';

const { showSnackbar } = useSnackbar();
showSnackbar('Message', 'success', 5000);
```

### Snackbar Design Guidelines
스낵바 컴포넌트는 어떤 페이지에 종속되어서는 안 되며, 페이지 전환 후에도 계속 노출되어야 합니다.

#### Global Snackbar Rules
- **페이지 독립성**: 스낵바 컴포넌트는 특정 페이지 컴포넌트 내부에 배치하지 않습니다
- **전역 관리**: Context API를 사용하여 전역 상태로 관리합니다
- **페이지 전환 지속성**: 페이지가 전환되어도 스낵바는 계속 표시되어야 합니다
- **Router 내부 배치**: Provider는 Router 내부에 배치하여 `useNavigate` 사용이 가능하도록 합니다

#### Implementation Pattern
1. **Context API를 사용한 전역 스낵바 관리**
   ```typescript
   // src/context/SendingStatusContext.tsx
   export const SendingStatusProvider = ({ children }: { children: React.ReactNode }) => {
     const [status, setStatus] = useState<SendingStatus>(null);
     const [open, setOpen] = useState(false);

     // 상태 관리 로직...

     return (
       <SendingStatusContext.Provider value={{ showSendingStatus, updateSendingStatus, closeSendingStatus }}>
         {children}
         <SendingStatusSnackbar
           open={open}
           status={status}
           onClose={closeSendingStatus}
         />
       </SendingStatusContext.Provider>
     );
   };
   ```

2. **App.tsx에 Provider 배치**
   ```typescript
   // Router 내부에 Provider 배치 (useNavigate 사용을 위해)
   <Router>
     <SendingStatusProvider>
       <Routes>
         {/* routes */}
       </Routes>
     </SendingStatusProvider>
   </Router>
   ```

3. **페이지에서 Context 사용**
   ```typescript
   // 페이지 컴포넌트 내부
   import { useSendingStatus } from '../context/SendingStatusContext';

   const { showSendingStatus, updateSendingStatus } = useSendingStatus();

   const handleSend = async () => {
     showSendingStatus();
     updateSendingStatus('request');
     // ... 로직
     updateSendingStatus('sending');
     // ... 로직
     updateSendingStatus('completed');
   };
   ```

#### Status-Based Snackbar (발송 상태 스낵바)
발송 상태와 같은 단계별 프로세스를 표시하는 스낵바는 다음과 같은 패턴을 따릅니다:

- **상태 단계**: `request` → `sending` → `completed`
- **UI 표시 위치**: 화면 우측 하단 고정
- **로딩 애니메이션**: `sending` 상태일 때 `CircularProgress` 표시
- **완료 후 액션**: `completed` 상태일 때 추가 액션 버튼 (예: "발송 이력 보기") 표시

#### Key Points
- **Provider 위치**: Router 내부에 배치하여 Router 컨텍스트 접근 가능
- **컴포넌트 위치**: 스낵바 컴포넌트는 Provider 내부에서 렌더링
- **상태 관리**: Context를 통해 전역 상태로 관리
- **페이지 전환**: 페이지 전환 시 스낵바 상태 유지
- **자동 닫기**: `sending` 상태일 때는 자동 닫기 방지

#### Summary
- **전역 관리**: Context API로 전역 상태 관리
- **페이지 독립**: 페이지 컴포넌트에 종속되지 않음
- **지속성**: 페이지 전환 후에도 계속 표시
- **Router 내부**: Provider는 Router 내부에 배치
- **상태 기반**: 단계별 상태에 따른 UI 변경 지원

### Navigation
```typescript
const navigate = useNavigate();
navigate('/auto-mail');
```

### Local Storage
```typescript
import { saveTemplate, getTemplate } from '../utils/storage';
saveTemplate(groupId, templateId, title, content);
const template = getTemplate(groupId, templateId);
```

### Theme Usage
```typescript
const theme = useTheme();
// Or in sx prop: sx={{ color: 'primary.main' }}
```

### Query Parameters for Search, Filtering, and Table State
검색 기능, 필터링 기능, 테이블 컴포넌트가 있는 페이지는 쿼리 파라미터를 통해 상태를 URL에 저장하고 공유할 수 있어야 합니다.

#### When to Use Query Parameters
- 검색 기능이 있는 페이지
- 필터링 기능이 있는 페이지
- 테이블 컴포넌트가 있는 페이지 (페이지네이션 포함)
- 탭 기반 UI가 있는 페이지
- 상세 모달을 열 수 있는 페이지

#### Implementation Pattern
1. **Import Required Hooks**
   ```typescript
   import { useEffect } from 'react';
   import { useSearchParams } from 'react-router-dom';
   ```

2. **Initialize State and Query Parameters**
   ```typescript
   const [searchParams, setSearchParams] = useSearchParams();
   const [isInitialized, setIsInitialized] = useState(false);

   // 페이지 상태들
   const [tabValue, setTabValue] = useState<number>(0);
   const [searchQuery, setSearchQuery] = useState<string>('');
   const [searchType, setSearchType] = useState<string>('all');
   const [filter1, setFilter1] = useState<string>('all');
   const [page, setPage] = useState<number>(0);
   const [rowsPerPage, setRowsPerPage] = useState<number>(10);
   ```

3. **Read Initial Values from URL Parameters (One-time)**
   ```typescript
   useEffect(() => {
     if (isInitialized) return; // 이미 초기화되었으면 실행하지 않음

     // URL 파라미터 읽기
     const tabParam = searchParams.get('tab');
     const searchParam = searchParams.get('search');
     const searchTypeParam = searchParams.get('searchType');
     const filter1Param = searchParams.get('filter1');
     const pageParam = searchParams.get('page');
     const rowsPerPageParam = searchParams.get('rowsPerPage');
     const itemIdParam = searchParams.get('itemId'); // 상세 모달용

     // itemId 파라미터가 있으면 해당 항목을 찾아서 모달 열기
     if (itemIdParam) {
       const item = items.find((item) => item.id === itemIdParam);
       if (item) {
         setSelectedItem(item);
         setOpenModal(true);
         // URL에서 itemId 파라미터 제거
         const newParams = new URLSearchParams(searchParams);
         newParams.delete('itemId');
         setSearchParams(newParams, { replace: true });
       }
     }

     // URL 파라미터에서 초기값 설정
     if (tabParam) {
       const tabIndex = tabParam === 'tab1' ? 0 : tabParam === 'tab2' ? 1 : 0;
       setTabValue(tabIndex);
     }
     if (searchParam !== null) {
       setSearchQuery(searchParam);
     }
     if (searchTypeParam) {
       setSearchType(searchTypeParam);
     }
     if (filter1Param) {
       setFilter1(filter1Param);
     }
     if (pageParam) {
       const pageNum = parseInt(pageParam, 10);
       if (!isNaN(pageNum)) {
         setPage(pageNum);
       }
     }
     if (rowsPerPageParam) {
       const rowsNum = parseInt(rowsPerPageParam, 10);
       if (!isNaN(rowsNum)) {
         setRowsPerPage(rowsNum);
       }
     }

     setIsInitialized(true);
   }, [isInitialized, searchParams, setSearchParams, items]);
   ```

4. **Update URL Parameters When State Changes**
   ```typescript
   useEffect(() => {
     if (!isInitialized) return; // 초기화되지 않았으면 실행하지 않음

     const newParams = new URLSearchParams();

     // 탭 선택
     if (tabValue === 0) {
       newParams.set('tab', 'tab1');
     } else if (tabValue === 1) {
       newParams.set('tab', 'tab2');
     }

     // 검색 관련
     if (searchQuery) {
       newParams.set('search', searchQuery);
     }
     if (searchType !== 'all') {
       newParams.set('searchType', searchType);
     }

     // 필터
     if (filter1 !== 'all') {
       newParams.set('filter1', filter1);
     }

     // 페이지네이션
     if (page !== 0) {
       newParams.set('page', String(page));
     }
     if (rowsPerPage !== 10) {
       newParams.set('rowsPerPage', String(rowsPerPage));
     }

     // 현재 URL과 비교하여 변경사항이 있을 때만 업데이트
     const currentParams = searchParams.toString();
     const newParamsStr = newParams.toString();

     if (currentParams !== newParamsStr) {
       setSearchParams(newParams, { replace: true });
     }
   }, [
     tabValue,
     searchQuery,
     searchType,
     filter1,
     page,
     rowsPerPage,
     isInitialized,
     searchParams,
     setSearchParams,
   ]);
   ```

#### Key Points
- **isInitialized 플래그**: 초기화가 한 번만 실행되도록 보장
- **replace: true**: 브라우저 히스토리에 불필요한 항목이 쌓이지 않도록 함
- **조건부 업데이트**: 기본값이 아닌 경우에만 URL 파라미터에 추가
- **변경사항 체크**: 현재 URL과 비교하여 실제 변경사항이 있을 때만 업데이트
- **상세 모달**: `itemId` 파라미터를 통해 특정 항목의 상세 모달을 자동으로 열 수 있음

#### Example: Tab-Based UI with Multiple Pagination States
탭 기반 UI에서 각 탭마다 독립적인 페이지네이션 상태를 가질 때:

```typescript
// 각 탭별 페이지네이션 상태
const [autoPage, setAutoPage] = useState<number>(0);
const [autoRowsPerPage, setAutoRowsPerPage] = useState<number>(10);
const [manualPage, setManualPage] = useState<number>(0);
const [manualRowsPerPage, setManualRowsPerPage] = useState<number>(10);

// URL 파라미터 읽기
useEffect(() => {
  if (isInitialized) return;

  const autoPageParam = searchParams.get('autoPage');
  const autoRowsPerPageParam = searchParams.get('autoRowsPerPage');
  const manualPageParam = searchParams.get('manualPage');
  const manualRowsPerPageParam = searchParams.get('manualRowsPerPage');

  if (autoPageParam) {
    const pageNum = parseInt(autoPageParam, 10);
    if (!isNaN(pageNum)) {
      setAutoPage(pageNum);
    }
  }
  // ... 다른 파라미터들

  setIsInitialized(true);
}, [isInitialized, searchParams, setSearchParams]);

// URL 파라미터 업데이트
useEffect(() => {
  if (!isInitialized) return;

  const newParams = new URLSearchParams();

  if (autoPage !== 0) {
    newParams.set('autoPage', String(autoPage));
  }
  if (autoRowsPerPage !== 10) {
    newParams.set('autoRowsPerPage', String(autoRowsPerPage));
  }
  if (manualPage !== 0) {
    newParams.set('manualPage', String(manualPage));
  }
  if (manualRowsPerPage !== 10) {
    newParams.set('manualRowsPerPage', String(manualRowsPerPage));
  }

  // ... 변경사항 체크 및 업데이트
}, [autoPage, autoRowsPerPage, manualPage, manualRowsPerPage, isInitialized, searchParams, setSearchParams]);
```

#### Summary
- **검색/필터/테이블 페이지**: 항상 쿼리 파라미터 지원 구현
- **isInitialized 플래그**: 초기화 한 번만 실행
- **조건부 업데이트**: 기본값이 아닌 경우에만 URL에 추가
- **변경사항 체크**: 실제 변경이 있을 때만 업데이트
- **상세 모달**: itemId 파라미터로 자동 열기 지원

## Anti-Patterns to Avoid
- Don't use `any` type - use proper types
- Don't mix controlled and uncontrolled components
- Don't create Context without Provider
- Don't use inline styles - use `sx` prop
- Don't mutate state directly - use setState
- Don't forget dependency arrays in useEffect
- Don't use `var` - use `const` or `let`
- Don't create functions in JSX without useCallback when passed to memoized components
- **Don't use hardcoded colors** - always use theme colors for dark mode compatibility
- **Don't assume light mode only** - all styling must work in both light and dark modes

## Code Formatting
- Use 2 spaces for indentation
- Use single quotes for strings (TypeScript/JavaScript)
- Use trailing commas in multi-line objects/arrays
- Use semicolons
- Maximum line length: 120 characters (soft limit)

## When Adding New Features
1. Check if similar functionality exists
2. Follow existing patterns and conventions
3. Create reusable components when appropriate
4. Add TypeScript types for new data structures
5. Update Context if global state is needed
6. Use existing utility functions when possible
7. Test with Korean (IME) input when applicable
