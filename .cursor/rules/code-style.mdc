---
alwaysApply: true
---

# Code Style & Conventions

## TypeScript
- Use strict TypeScript with explicit types
- Prefer interfaces for object shapes, types for unions/intersections
- Use `as const` for literal types when needed (e.g., TinyMCE menu items)
- Avoid `any` - use `unknown` or proper types instead
- Use type assertions sparingly and only when necessary

## React Patterns
- Use functional components with hooks
- Prefer named exports for components
- Use `React.useRef` for DOM references and mutable values
- Use `React.useState` for local component state
- Use `React.useEffect` with proper dependency arrays
- Use `React.useCallback` and `React.useMemo` for performance optimization when needed

## Tab-Based UI Patterns
탭 기반 UI를 구현할 때는 각 탭마다 완전히 독립적인 컴포넌트와 로직을 사용해야 합니다.

### Tab Panel Structure
- MUI의 `Tabs`와 `Tab` 컴포넌트를 사용합니다
- 각 탭의 내용은 `CustomTabPanel` 컴포넌트로 감싸서 독립적으로 관리합니다
- `CustomTabPanel`은 `hidden` 속성과 조건부 렌더링을 사용하여 탭 전환을 처리합니다

Example pattern:
```typescript
interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function CustomTabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`tabpanel-${index}`}
      aria-labelledby={`tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 0 }}>{children}</Box>}
    </div>
  );
}
```

### Independent State Management
- **각 탭마다 독립적인 상태를 사용합니다**
  - 하나의 공유 상태를 값만 변경해서 사용하지 않습니다
  - 각 탭마다 별도의 `useState`로 페이지네이션 상태를 관리합니다
  - 예: `autoPage`, `manualPage`, `recipientPage` (각각 독립적인 상태)

### Independent Handler Functions
- **각 탭마다 독립적인 핸들러 함수를 사용합니다**
  - 공유 핸들러 함수를 사용하지 않습니다
  - 각 탭마다 별도의 핸들러 함수를 정의합니다
  - 예: `handleAutoPageChange`, `handleManualPageChange`, `handleRecipientPageChange`

### Independent Logic Separation
- **각 탭마다 독립적인 필터링 및 페이지네이션 로직을 사용합니다**
  - 하나의 공유 로직을 조건문으로 분기하지 않습니다
  - 각 탭마다 별도의 `useMemo`로 필터링 및 페이지네이션을 처리합니다
  - 예: `autoFiltered`, `autoPaginated`, `manualFiltered`, `manualPaginated`, `recipientFiltered`, `recipientPaginated`

### Independent Table Components
- **각 탭마다 독립적인 테이블 컴포넌트를 사용합니다**
  - 하나의 테이블 컴포넌트를 값만 변경해서 재사용하지 않습니다
  - 각 탭의 `CustomTabPanel` 내부에 완전히 독립적인 `Table` 컴포넌트를 배치합니다
  - 각 테이블은 자신만의 헤더, 바디, 페이지네이션을 가집니다

Example structure:
```typescript
<CustomTabPanel value={tabValue} index={0}>
  <TableContainer>
    <Table stickyHeader>
      {/* 자동 탭 전용 테이블 */}
    </Table>
  </TableContainer>
  {/* 자동 탭 전용 페이지네이션 */}
</CustomTabPanel>

<CustomTabPanel value={tabValue} index={1}>
  <TableContainer>
    <Table stickyHeader>
      {/* 수동 탭 전용 테이블 */}
    </Table>
  </TableContainer>
  {/* 수동 탭 전용 페이지네이션 */}
</CustomTabPanel>
```

### Summary
- **독립적인 상태**: 각 탭마다 별도의 `useState` 사용
- **독립적인 핸들러**: 각 탭마다 별도의 핸들러 함수 정의
- **독립적인 로직**: 각 탭마다 별도의 `useMemo`로 필터링/페이지네이션 처리
- **독립적인 테이블**: 각 탭마다 별도의 `Table` 컴포넌트 사용
- **공유하지 않음**: 하나의 컴포넌트/함수/상태를 값만 변경해서 재사용하지 않음

## Component Organization
- **Components** (`src/components/`): Reusable, presentational components
- **Pages** (`src/pages/`): Route-level components that compose multiple components
- **Context** (`src/context/`): Global state providers with custom hooks
- Each component should be in its own file with matching name

## Naming Conventions
- **Components**: PascalCase (e.g., `MailTemplatePage.tsx`)
- **Files**: Match component name (e.g., `Layout.tsx` for `Layout` component)
- **Hooks**: Start with `use` (e.g., `useSnackbar`, `useLanguage`)
- **Context**: PascalCase with `Context` suffix (e.g., `SnackbarContext`)
- **Types/Interfaces**: PascalCase (e.g., `MailTemplate`, `Language`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `AVAILABLE_VARIABLES`)
- **Functions**: camelCase (e.g., `handleSave`, `getTemplate`)

## MUI Usage
- Always import MUI components from `@mui/material` or `@mui/icons-material`
- Use the `sx` prop for styling instead of `style` prop
- Use theme-aware values in `sx` (e.g., `'primary.main'`, `'text.secondary'`)
- Prefer MUI components over native HTML elements when possible
- Use `styled` API for complex reusable styled components
- Use `useTheme` hook when theme values are needed in JavaScript

## Context API Patterns
- Create Context files in `src/context/` directory
- Export a Provider component and a custom hook (e.g., `useSnackbar`)
- Provider should wrap the entire app in `App.tsx`
- Custom hook should throw error if used outside provider
- Use `useCallback` for context functions to prevent unnecessary re-renders

Example pattern:
```typescript
const Context = createContext<ContextType | undefined>(undefined);

export const useContext = () => {
  const context = useContext(Context);
  if (!context) {
    throw new Error('useContext must be used within Provider');
  }
  return context;
};

export const Provider = ({ children }: { children: React.ReactNode }) => {
  // implementation
  return <Context.Provider value={value}>{children}</Context.Provider>;
};
```

## Routing
- Use React Router DOM v7 patterns
- Define routes in `App.tsx`
- Use `useNavigate` for programmatic navigation
- Use `useLocation` for current route information
- Use `useParams` for route parameters
- Use `Link` component for navigation links

## TinyMCE Integration
- Use `@tinymce/tinymce-react` Editor component
- Keep editor as uncontrolled component (use `initialValue`, not `value`)
- Use `onInit` to get editor reference
- Use `onEditorChange` sparingly to avoid cursor issues with IME input
- Retrieve content with `editorRef.current.getContent()` when needed
- Use `editor.getContent({ format: 'text' })` to get plain text
- **Editor 컴포넌트에 `key` 속성은 사용하지 않습니다**: Editor 컴포넌트는 React의 `key` prop을 사용하지 않으며, 각 언어별로 독립적인 에디터 인스턴스를 관리하기 위해 `editorRefs`를 사용합니다

### TinyMCE Language Configuration
TinyMCE 에디터의 언어 설정은 `init` 객체의 `language` 속성을 통해 설정합니다. **TinyMCE 공식 언어 코드만 사용해야 하며, 공식 목록에 없는 형식은 절대 사용하지 않습니다.**

**프로젝트에서 사용하는 언어:**
- **한국어**: `'ko-KR'` (TinyMCE 공식 코드: Korean (Korea))
- **영어**: `'en'` (TinyMCE 공식 코드: English)
- **베트남어**: `'vi'` (TinyMCE 공식 코드: Vietnamese)

**Example:**
```typescript
<Editor
  init={{
    ...editorConfig,
    language: lang === 'ko' ? 'ko-KR' : lang === 'vi' ? 'vi' : 'en',
  }}
/>
```

**Important Notes:**
- **한국어**: 반드시 `'ko-KR'` 형식을 사용합니다 (`'ko'`만 사용하거나 `'ko_KR'` 형식은 절대 사용하지 않습니다)
- **베트남어**: 반드시 `'vi'`만 사용합니다 (`'vi-VN'` 또는 `'vi_VN'` 형식은 절대 사용하지 않습니다)
- **영어**: `'en'`을 사용합니다
- **공식 언어 코드만 사용**: TinyMCE 공식 언어 코드 목록에 정의된 형식만 사용해야 합니다
- **탭 변경 시 언어 설정**: 탭을 변경할 때 에디터는 재생성되지 않으며, 각 언어별로 독립적인 에디터 인스턴스를 유지합니다. 에디터는 항상 렌더링되지만 `display` 속성으로 보이기/숨기기만 처리하여 내용이 유지되도록 합니다

**TinyMCE 공식 언어 코드 목록:**
프로젝트에서 사용하는 언어 외에도 다음 공식 언어 코드를 사용할 수 있습니다:
- `ar` (Arabic), `eu` (Basque), `bg-BG` (Bulgarian), `ca` (Catalan), `zh-CN` (Chinese China), `zh-TW` (Chinese Taiwan), `hr` (Croatian), `cs` (Czech), `da` (Danish), `nl` (Dutch), `fi` (Finnish), `fr-FR` (French France), `de` (German), `el` (Greek), `he-IL` (Hebrew Israel), `hi` (Hindi), `hu-HU` (Hungarian Hungary), `id` (Indonesian), `it` (Italian), `ja` (Japanese), `kk` (Kazakh), `ms` (Malay), `nb-NO` (Norwegian Bokmål Norway), `fa` (Persian), `pl` (Polish), `pt-BR` (Portuguese Brazil), `pt-PT` (Portuguese Portugal), `ro` (Romanian), `ru` (Russian), `sk` (Slovak), `sl-SI` (Slovenian Slovenia), `es` (Spanish), `sv-SE` (Swedish Sweden), `th-TH` (Thai Thailand), `tr` (Turkish), `uk` (Ukrainian), `vi` (Vietnamese)

## State Management
- **Local State**: Use `useState` for component-specific state
- **Global State**: Use Context API (ColorMode, Language, Snackbar)
- **Persistent State**: Use `localStorage` via utility functions in `src/utils/storage.ts`
- Avoid prop drilling - use Context when state is needed across multiple components

## Error Handling
- Use try-catch for async operations
- Display user-friendly error messages via Snackbar
- Log errors to console for debugging
- Validate inputs before processing

## File Imports
- Group imports: external libraries, MUI components, internal components, utilities, types
- Use absolute imports from `src/` (e.g., `import { useSnackbar } from '../context/SnackbarContext'`)
- Use named imports for MUI components
- Use default imports for React Router hooks

## Performance
- Use `React.memo` for expensive components that re-render frequently
- Use `useCallback` for functions passed as props to memoized components
- Use `useMemo` for expensive computations
- Lazy load heavy components when appropriate
- Avoid creating functions/objects in render without memoization

## Accessibility
- Use semantic HTML elements
- Add `aria-label` to icon-only buttons
- Ensure keyboard navigation works
- Use MUI components which have built-in accessibility

## Testing Considerations
- Write testable components (pure functions when possible)
- Keep business logic separate from UI logic
- Use dependency injection for external services
