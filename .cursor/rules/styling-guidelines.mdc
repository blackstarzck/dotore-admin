---
alwaysApply: true
---

# Styling Guidelines

## Basic Styling Guidelines
- Use MUI's `sx` prop for component-level styles
- Use theme spacing units (e.g., `sx={{ p: 3, mb: 2 }}`)
- Use theme colors (e.g., `'primary.main'`, `'error.lighter'`)
- Use responsive breakpoints when needed
- Keep styles co-located with components
- Use `styled` API for complex reusable styled components

## Dark Mode Support Guidelines
**모든 작업에 있어서 다크모드가 지원되어야 합니다.** 이는 필수 요구사항이며, 모든 컴포넌트, 페이지, 스타일링 작업에서 반드시 고려해야 합니다.

### Core Principles
- **항상 다크모드 지원**: 모든 UI 컴포넌트는 라이트 모드와 다크 모드 모두에서 올바르게 작동해야 합니다
- **테마 색상 사용**: 하드코딩된 색상은 절대 사용하지 않습니다
- **자동 색상 전환**: MUI 테마 시스템을 통해 자동으로 색상이 전환되도록 구현합니다
- **테스트 필수**: 모든 스타일 변경사항은 라이트 모드와 다크 모드 모두에서 테스트해야 합니다

### Color Usage Rules
- **절대 금지**: 하드코딩된 색상 값 사용 금지
  - ❌ `#ffffff`, `#000000`, `#f5f5f5` 등 직접 색상 값 사용 금지
  - ❌ `rgb(255, 255, 255)`, `rgba(0, 0, 0, 0.5)` 등 직접 색상 값 사용 금지
  - ✅ 테마 색상 값 사용: `'text.primary'`, `'background.paper'`, `'primary.main'` 등

- **필수 사용**: 테마 인식 색상 값 사용
  - 텍스트 색상: `'text.primary'`, `'text.secondary'`, `'text.disabled'`
  - 배경 색상: `'background.paper'`, `'background.default'`
  - 구분선 색상: `'divider'`
  - 테마 색상: `'primary.main'`, `'secondary.main'`, `'error.main'`, `'warning.main'`, `'info.main'`, `'success.main'`

- **커스텀 색상 사용 시**: 테마 팔레트에 라이트/다크 변형 모두 제공
  ```typescript
  // 테마 팔레트에 추가
  const theme = createTheme({
    palette: {
      mode: 'light', // 또는 'dark'
      custom: {
        light: '#f5f5f5', // 라이트 모드용
        dark: '#1a1a1a',  // 다크 모드용
      }
    }
  });
  ```

### Implementation Patterns

#### Using sx Prop (권장)
```typescript
// ✅ 올바른 방법: 테마 색상 사용
<Box
  sx={{
    bgcolor: 'background.paper',
    color: 'text.primary',
    border: '1px solid',
    borderColor: 'divider',
  }}
>
  <Typography color="text.secondary">Content</Typography>
</Box>

// ❌ 잘못된 방법: 하드코딩된 색상
<Box
  sx={{
    bgcolor: '#ffffff',
    color: '#000000',
    border: '1px solid #e0e0e0',
  }}
>
  <Typography sx={{ color: '#666666' }}>Content</Typography>
</Box>
```

#### Using useTheme Hook
```typescript
import { useTheme } from '@mui/material/styles';

const MyComponent = () => {
  const theme = useTheme();

  return (
    <Box
      sx={{
        bgcolor: theme.palette.mode === 'dark'
          ? theme.palette.grey[800]
          : theme.palette.grey[100],
        color: theme.palette.text.primary,
      }}
    >
      Content
    </Box>
  );
};
```

#### Using styled API
```typescript
import { styled } from '@mui/material/styles';

const StyledBox = styled(Box)(({ theme }) => ({
  backgroundColor: theme.palette.background.paper,
  color: theme.palette.text.primary,
  border: `1px solid ${theme.palette.divider}`,
  '&:hover': {
    backgroundColor: theme.palette.action.hover,
  },
}));
```

#### Custom CSS (최후의 수단)
커스텀 CSS를 사용해야 하는 경우, CSS 변수나 테마 인식 셀렉터를 사용합니다:

```typescript
// ✅ CSS 변수 사용
const styles = {
  container: {
    backgroundColor: 'var(--mui-palette-background-paper)',
    color: 'var(--mui-palette-text-primary)',
  }
};

// ✅ 테마 인식 셀렉터
const styles = {
  container: {
    '@media (prefers-color-scheme: dark)': {
      backgroundColor: '#1a1a1a',
      color: '#ffffff',
    },
    '@media (prefers-color-scheme: light)': {
      backgroundColor: '#ffffff',
      color: '#000000',
    },
  }
};
```

### Component-Specific Guidelines

#### Buttons
```typescript
// ✅ 올바른 방법
<Button
  variant="contained"
  sx={{
    bgcolor: 'primary.main',
    color: 'primary.contrastText',
    '&:hover': {
      bgcolor: 'primary.dark',
    },
  }}
>
  Click me
</Button>
```

#### Cards and Papers
```typescript
// ✅ 올바른 방법
<Paper
  sx={{
    bgcolor: 'background.paper',
    border: '1px solid',
    borderColor: 'divider',
    boxShadow: 'none',
  }}
>
  Content
</Paper>
```

#### Tables
```typescript
// ✅ 올바른 방법
<TableContainer component={Paper}>
  <Table>
    <TableHead>
      <TableRow>
        <TableCell sx={{ color: 'text.primary' }}>Header</TableCell>
      </TableRow>
    </TableHead>
    <TableBody>
      <TableRow>
        <TableCell sx={{ color: 'text.primary' }}>Data</TableCell>
      </TableRow>
    </TableBody>
  </Table>
</TableContainer>
```

#### Dialogs and Modals
```typescript
// ✅ 올바른 방법
<Dialog
  PaperProps={{
    sx: {
      bgcolor: 'background.paper',
      color: 'text.primary',
    },
  }}
>
  <DialogTitle sx={{ color: 'text.primary' }}>Title</DialogTitle>
  <DialogContent sx={{ color: 'text.primary' }}>Content</DialogContent>
</Dialog>
```

#### Icons
```typescript
// ✅ 올바른 방법
<IconButton sx={{ color: 'text.primary' }}>
  <Icon />
</IconButton>
```

### Image and Media Handling
- **이미지 배경**: 투명 배경 이미지는 다크모드에서도 잘 보이도록 고려
- **로고**: 다크모드용 로고 버전이 필요할 수 있음
- **아이콘**: MUI 아이콘은 자동으로 테마 색상을 따르지만, 커스텀 아이콘은 색상 지정 필요

### Testing Checklist
모든 스타일 변경 후 다음을 확인해야 합니다:

- [ ] 라이트 모드에서 모든 요소가 올바르게 표시되는가?
- [ ] 다크 모드에서 모든 요소가 올바르게 표시되는가?
- [ ] 텍스트 가독성이 양쪽 모드에서 충분한가?
- [ ] 배경과 텍스트의 대비가 충분한가?
- [ ] 구분선과 테두리가 양쪽 모드에서 명확한가?
- [ ] 호버 상태가 양쪽 모드에서 올바르게 작동하는가?
- [ ] 포커스 상태가 양쪽 모드에서 명확한가?
- [ ] 선택된 상태가 양쪽 모드에서 명확한가?

### Common Mistakes to Avoid
- ❌ **하드코딩된 색상**: `#ffffff`, `#000000` 등 직접 색상 값 사용
- ❌ **라이트 모드만 고려**: 다크 모드 테스트 누락
- ❌ **배경색만 변경**: 텍스트 색상도 함께 변경하지 않음
- ❌ **투명도 무시**: `rgba(0, 0, 0, 0.1)` 같은 투명도가 다크 모드에서 보이지 않을 수 있음
- ❌ **그림자 무시**: 다크 모드에서 그림자가 보이지 않을 수 있음
- ❌ **이미지 배경**: 투명 배경 이미지가 다크 모드에서 보이지 않을 수 있음

### Summary
- **필수 요구사항**: 모든 작업에서 다크모드 지원 필수
- **테마 색상 사용**: 하드코딩된 색상 절대 금지
- **자동 전환**: MUI 테마 시스템 활용
- **테스트 필수**: 라이트/다크 모드 모두 테스트
- **일관성 유지**: 모든 컴포넌트에서 동일한 패턴 적용

## Table Design Guidelines
모든 테이블은 일관된 디자인을 유지해야 합니다. 문의 목록 테이블(`InquiryListPage.tsx`)의 스타일 규칙을 표준으로 따릅니다.

### Table Loading UI (필수)
**테이블과 관련된 컴포넌트를 만들 때 반드시 테이블 로딩 UI가 있어야 하며, 이는 테이블에 데이터를 넣기 전에 보여져야 합니다.**

- **로딩 상태 관리**: `isLoading` 또는 `isLoadingData` 같은 상태 변수를 사용하여 로딩 상태를 관리합니다
- **로딩 UI 표시 위치**: `TableBody` 내부에서 로딩 상태일 때 로딩 UI를 표시합니다
- **로딩 UI 구조**: `CircularProgress`와 로딩 메시지를 포함한 `TableRow`를 사용합니다
- **데이터 로드 전 표시**: 데이터를 불러오기 전에 로딩 UI가 먼저 표시되어야 합니다

Example pattern:
```typescript
const [isLoading, setIsLoading] = useState<boolean>(false);
const [data, setData] = useState<DataType[]>([]);

// 데이터 로드 함수
const loadData = async () => {
  setIsLoading(true);
  try {
    // 네트워크 지연 시뮬레이션 또는 실제 API 호출
    await new Promise(resolve => setTimeout(resolve, 500));
    const fetchedData = await fetchDataFromAPI();
    setData(fetchedData);
  } finally {
    setIsLoading(false);
  }
};

// 컴포넌트 마운트 시 데이터 로드
useEffect(() => {
  loadData();
}, []);

// 테이블 렌더링
<TableBody>
  {isLoading ? (
    <TableRow>
      <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 2 }}>
          <CircularProgress size={40} />
          <Typography variant="body2" color="text.secondary">
            데이터를 불러오는 중...
          </Typography>
        </Box>
      </TableCell>
    </TableRow>
  ) : data.length === 0 ? (
    <TableRow>
      <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 1 }}>
          <Typography variant="h6" color="text.secondary">
            조회된 데이터가 없습니다.
          </Typography>
        </Box>
      </TableCell>
    </TableRow>
  ) : (
    data.map((item) => (
      <TableRow key={item.id}>
        {/* 데이터 행 렌더링 */}
      </TableRow>
    ))
  )}
</TableBody>
```

**Key Points:**
- **필수 구현**: 모든 테이블 컴포넌트에 로딩 UI 구현 필수
- **데이터 로드 전 표시**: 데이터를 불러오기 전에 로딩 UI가 먼저 표시되어야 함
- **로딩 상태 관리**: 비동기 데이터 로드 함수에서 로딩 상태를 적절히 관리
- **일관된 UI**: 모든 테이블에서 동일한 로딩 UI 패턴 사용
- **사용자 경험**: 데이터 로드 중 사용자에게 명확한 피드백 제공

### Table Container & Wrapper
- 테이블은 `Paper` 컴포넌트로 감싸야 합니다
- Paper 스타일:
  ```typescript
  <Paper
    sx={{
      width: '100%',
      borderRadius: 2,
      border: '1px solid',
      borderColor: 'divider',
      boxShadow: 'none',
    }}
  >
    {/* 테이블 내용 */}
  </Paper>
  ```
- `TableContainer`는 Paper 없이 직접 사용합니다 (Paper 내부에 위치)

### Table Structure
- `Table` 컴포넌트에 `stickyHeader` 속성을 항상 사용합니다
  ```typescript
  <Table stickyHeader>
  ```

### Table Head (헤더)
- `TableCell` 헤더에는 `fontWeight`를 명시하지 않습니다 (기본 스타일 사용)
- 모든 헤더 셀에 `whiteSpace: 'nowrap'`을 사용합니다
- 필요시 `width`, `minWidth` 속성을 사용하여 컬럼 너비를 지정합니다
  ```typescript
  <TableCell sx={{ whiteSpace: 'nowrap' }}>헤더 텍스트</TableCell>
  // 또는
  <TableCell sx={{ width: '100px', minWidth: '100px', whiteSpace: 'nowrap' }}>헤더 텍스트</TableCell>
  ```

### Table Body (바디)
- 모든 바디 셀에 `whiteSpace: 'nowrap'`을 사용합니다
- 셀 내부 텍스트는 `Typography` 컴포넌트로 감싸고 `variant="body2"`를 사용합니다
- 기본 텍스트: `variant="body2"` (색상 없음, 기본 `text.primary`)
- 보조 텍스트: `variant="body2" color="text.secondary"`
- 모든 텍스트에 `noWrap` 속성을 추가합니다
  ```typescript
  <TableCell sx={{ whiteSpace: 'nowrap' }}>
    <Typography variant="body2" noWrap>
      기본 텍스트
    </Typography>
  </TableCell>
  <TableCell sx={{ whiteSpace: 'nowrap' }}>
    <Typography variant="body2" color="text.secondary" noWrap>
      보조 텍스트
    </Typography>
  </TableCell>
  ```

### Empty State (빈 데이터)
- 빈 데이터 셀은 `colSpan`을 사용하여 전체 컬럼을 차지합니다
- `align="center"`와 `sx={{ py: 8 }}`을 사용합니다
- `Box`로 감싸서 `Typography`를 사용합니다
  ```typescript
  <TableRow>
    <TableCell colSpan={컬럼수} align="center" sx={{ py: 8 }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 1 }}>
        <Typography variant="h6" color="text.secondary">
          조회된 데이터가 없습니다.
        </Typography>
      </Box>
    </TableCell>
  </TableRow>
  ```

### Table Row
- 데이터 행에는 `hover` 속성을 사용합니다
- 클릭 가능한 행은 `sx={{ cursor: 'pointer' }}`를 추가합니다

### Table Schema Definitions
**사이드바에서 보여지는 모든 페이지에 테이블 컴포넌트가 있는 경우, 각 테이블의 구조를 정의합니다. 나중에 데이터베이스 스키마 설정 시 필요합니다.**

#### 1. InquiryListPage (문의 목록) - `/`
**테이블명**: `inquiries`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 문의 고유 ID (PK) | ❌ | ✅ |
| `number` | number | 문의 번호 | ❌ | ✅ |
| `category` | string | 카테고리 (InquiryCategory enum) | ✅ | ✅ |
| `user_name` | string | 사용자 이름(아이디) | ✅ | ✅ |
| `user_nickname` | string | 사용자 닉네임 | ✅ | ❌ |
| `user_email` | string | 사용자 이메일 | ✅ | ✅ |
| `user_type` | string | 작성자 유형 (UserType enum) | ✅ | ✅ |
| `title` | string | 문의 내용 (제목) | ✅ | ✅ |
| `attachments` | array | 첨부파일 목록 | ❌ | ❌ |
| `user_country` | string | 사용자 국적 | ✅ | ✅ |
| `created_at` | datetime | 등록일시 | ✅ | ✅ |
| `status` | string | 답변 상태 (InquiryStatus enum) | ✅ | ✅ |
| `answer_content` | text | 답변 내용 | ❌ | ❌ |
| `answerer_id` | string | 답변자 ID | ❌ | ❌ |
| `answered_at` | datetime | 답변 일시 | ❌ | ❌ |

**관계**:
- `user_id` (외래키): 사용자 테이블 참조
- `answerer_id` (외래키): 관리자 테이블 참조

#### 2. MailGroupPage (발송 그룹) - `/mail-group`
**테이블명**: `send_groups`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 그룹 고유 ID (PK) | ❌ | ✅ |
| `name` | MultilingualContent | 그룹 이름 (다국어) | ❌ | ✅ |
| `description` | MultilingualContent | 그룹 설명 (다국어) | ❌ | ❌ |
| `nationality` | string | 국적 조건 (표시용) | ❌ | ❌ |
| `age_range` | string | 연령 범위 조건 (표시용) | ❌ | ❌ |
| `gender` | string | 성별 조건 (표시용) | ❌ | ❌ |
| `user_type` | string | 가입 유형 조건 (표시용) | ❌ | ❌ |
| `signup_method` | string | 가입 방식 조건 (표시용) | ❌ | ❌ |
| `signup_date` | string | 가입 일자 조건 (표시용) | ❌ | ❌ |
| `subscription_status` | string | 구독 여부 조건 (표시용) | ❌ | ❌ |
| `activity_status` | string | 활동 여부 조건 (표시용) | ❌ | ❌ |
| `member_count` | number | 예상 발송 인원 수 | ❌ | ✅ |
| `query` | JSON | Query Builder 조건 (RuleGroupType) | ❌ | ✅ |
| `created_at` | datetime | 생성 일시 | ❌ | ✅ |
| `updated_at` | datetime | 수정 일시 | ❌ | ✅ |
| `member_count_checked_at` | datetime | 인원 조회 일시 | ❌ | ❌ |

**관계**:
- `query` 필드는 JSON 형식으로 저장되며, `react-querybuilder`의 `RuleGroupType` 구조를 따릅니다.

#### 3. MailHistoryPage (발송 이력) - `/mail-history`

##### 3-1. 자동 메일 탭
**테이블명**: `auto_mail_history`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 발송 이력 고유 ID (PK) | ❌ | ✅ |
| `template_name` | string | 템플릿 이름 | ❌ | ✅ |
| `group_name` | string | 그룹 이름 | ❌ | ✅ |
| `recipient_count` | number | 수신자 수 | ❌ | ✅ |
| `sent_count` | number | 발송 성공 수 | ❌ | ✅ |
| `failed_count` | number | 발송 실패 수 | ❌ | ✅ |
| `type` | string | 발송 유형 ('auto') | ❌ | ✅ |

**관계**:
- `template_id` (외래키): 템플릿 테이블 참조
- `group_id` (외래키): 발송 그룹 테이블 참조
- `successful_recipients` (JSON): 성공한 수신자 목록 (각 항목에 `sentAt` 포함)
- `failed_recipients` (JSON): 실패한 수신자 목록 (각 항목에 `sentAt` 포함)

##### 3-2. 수동 메일 탭
**테이블명**: `manual_mail_history`

| 컬럼명 | 타입 | 설명 | 정렬 가능 | 필수 |
|--------|------|------|----------|------|
| `id` | string | 발송 이력 고유 ID (PK) | ❌ | ✅ |
| `template_name` | string | 템플릿 이름 | ❌ | ✅ |
| `group_name` | string | 그룹 이름 | ❌ | ✅ |
| `recipient_count` | number | 수신자 수 | ❌ | ✅ |
| `sent_count` | number | 발송 성공 수 | ❌ | ✅ |
| `failed_count` | number | 발송 실패 수 | ❌ | ✅ |
| `status` | string | 발송 상태 | ❌ | ✅ |
| `type` | string | 발송 유형 ('manual') | ❌ | ✅ |
| `sent_date` | datetime | 발송일시 | ❌ | ✅ |
| `sent_by` | string | 발송자 ID | ❌ | ✅ |

**관계**:
- `template_id` (외래키): 템플릿 테이블 참조
- `group_id` (외래키): 발송 그룹 테이블 참조
- `sent_by` (외래키): 관리자 테이블 참조
- `successful_recipients` (JSON): 성공한 수신자 목록
- `failed_recipients` (JSON): 실패한 수신자 목록

**참고사항**:
- 자동 메일은 시스템에서 자동으로 발송되므로 `sent_date`와 `sent_by` 컬럼이 없습니다.
- 수동 메일은 관리자가 수동으로 발송하므로 `sent_date`와 `sent_by` 컬럼이 필요합니다.
- 자동 메일의 경우 각 수신자마다 발송 시간이 다를 수 있으므로, `successful_recipients`와 `failed_recipients` 배열의 각 항목에 개별 `sentAt` 필드가 포함됩니다.

### Summary
- **로딩 UI 필수**: 모든 테이블 컴포넌트에 로딩 UI 구현 필수, 데이터 로드 전에 표시
- **Paper로 감싸기**: 항상 Paper 컴포넌트로 테이블을 감싸고 표준 스타일 적용
- **stickyHeader**: 모든 Table에 stickyHeader 속성 사용
- **whiteSpace: 'nowrap'**: 모든 TableCell에 적용
- **Typography variant="body2"**: 모든 셀 텍스트에 사용
- **noWrap**: 모든 Typography에 적용
- **헤더 fontWeight**: 명시하지 않음 (기본 스타일)
- **빈 데이터**: py: 8, Box로 감싸서 Typography 사용
- **테이블 스키마 정의**: 각 페이지의 테이블 구조를 명확히 정의하여 데이터베이스 스키마 설계 시 참고
